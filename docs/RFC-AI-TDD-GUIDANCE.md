# RFC: AI-Generated TDD Guidance with Caching

> Status: **Proposed** | Priority: **Medium** | Created: 2024-12-03

## Summary

Replace the current regex-based TDD guidance generation with AI-generated guidance, cached in Feature List for performance.

## Problem Statement

Current TDD guidance in `src/tdd-guidance.ts` has limitations:

1. **Keyword-based E2E detection** - Only checks for 16 UI keywords (`user`, `display`, `form`, etc.), incomplete coverage
2. **Limited framework support** - Only 6 frameworks (Vitest, Jest, Mocha, pytest, Go, Cargo)
3. **No semantic understanding** - Pure regex pattern matching, no code context awareness
4. **No caching** - Regenerates every time, wastes computation

## Proposed Solution

Use AI Agent (Claude/Gemini/Codex CLI) to generate TDD guidance with intelligent analysis, then cache results in Feature List.

### Design Decisions

| Decision | Choice | Rationale |
|----------|--------|-----------|
| Cache invalidation | On acceptance change | Version field already tracks changes |
| Fallback behavior | Use regex-based | Graceful degradation when no AI available |
| Skeleton depth | Names + assertions | Balance between helpful and verbose |

## Technical Design

### New Type: `CachedTDDGuidance`

Add to `src/types.ts`:

```typescript
/**
 * Cached TDD guidance generated by AI
 * Stored in feature to avoid regeneration
 */
export interface CachedTDDGuidance {
  /** Generation timestamp (ISO 8601) */
  generatedAt: string;
  /** Agent that generated this (claude/gemini/codex) */
  generatedBy: string;
  /** Feature version when generated (for invalidation) */
  forVersion: number;
  /** Suggested test file paths */
  suggestedTestFiles: {
    unit: string[];
    e2e: string[];
  };
  /** Unit test cases with assertions */
  unitTestCases: Array<{
    name: string;
    assertions: string[];
  }>;
  /** E2E scenarios (if applicable) */
  e2eScenarios: Array<{
    name: string;
    steps: string[];
  }>;
  /** Detected/suggested test framework */
  frameworkHint?: string;
}
```

### Feature Interface Extension

Add to `Feature` interface in `src/types.ts`:

```typescript
/**
 * Cached TDD guidance from AI (optional)
 * Regenerated when feature.version changes
 */
tddGuidance?: CachedTDDGuidance;
```

### AI Prompt Template

```
Analyze this feature for TDD guidance:

Feature ID: ${feature.id}
Description: ${feature.description}
Module: ${feature.module}

Acceptance Criteria:
${feature.acceptance.map((a, i) => `${i + 1}. ${a}`).join('\n')}

Project test framework: ${capabilities?.testFramework || 'unknown'}
${capabilities?.e2eFramework ? `E2E framework: ${capabilities.e2eFramework}` : ''}

Generate JSON with this structure:
{
  "suggestedTestFiles": {
    "unit": ["tests/module/feature.test.ts"],
    "e2e": ["e2e/module/feature.spec.ts"]
  },
  "unitTestCases": [
    { "name": "should do X", "assertions": ["expect(...).toBe(...)", "expect(...).toHaveLength(...)"] }
  ],
  "e2eScenarios": [
    { "name": "user does X", "steps": ["navigate to page", "click button", "verify result"] }
  ],
  "frameworkHint": "vitest"
}

Rules:
- Generate one unit test case per acceptance criterion
- Only generate e2eScenarios for UI-related criteria
- Assertions should be specific and meaningful, not generic
- Use the detected framework syntax for assertions
```

### Cache Flow

```
agent-foreman next
       |
       v
+---------------------+
| feature.tddGuidance |
|     exists?         |
+---------------------+
       |
   Yes |          No
       v           v
+----------+  +---------------------+
| Check    |  | AI Agent            |
| version  |  | available?          |
+----------+  +---------------------+
       |            |
  Match |      Yes  |         No
       v            v          v
+----------+  +----------+ +----------------+
| Display  |  | Generate | | Use fallback   |
| cached   |  | with AI  | | regex-based    |
+----------+  +----------+ +----------------+
                    |
                    v
              +----------------+
              | Cache to       |
              | feature_list   |
              +----------------+
```

## Implementation Plan

### Step 1: Type Definitions

**File:** `src/types.ts`

- Add `CachedTDDGuidance` interface after line 86
- Add `tddGuidance?: CachedTDDGuidance` to `Feature` interface

### Step 2: AI Generator Module

**File:** `src/tdd-ai-generator.ts` (NEW)

```typescript
export async function generateTDDGuidanceWithAI(
  feature: Feature,
  capabilities: ExtendedCapabilities | null,
  cwd: string
): Promise<CachedTDDGuidance | null>
```

Logic:
1. Build prompt with feature info + capabilities
2. Call `callAnyAvailableAgent()` from `src/agents.ts`
3. Parse JSON response into `CachedTDDGuidance`
4. Return null if AI fails (caller uses fallback)

### Step 3: Feature List Helper

**File:** `src/feature-list.ts`

Add helper function:

```typescript
export function updateFeatureTDDGuidance(
  features: Feature[],
  featureId: string,
  guidance: CachedTDDGuidance
): Feature[] {
  return features.map((f) =>
    f.id === featureId ? { ...f, tddGuidance: guidance } : f
  );
}
```

### Step 4: Integrate into `runNext()`

**File:** `src/index.ts`

Replace lines 783-829 (TDD Guidance Section):

```typescript
// TDD Guidance Section
try {
  const capabilities = await detectCapabilities(cwd, { verbose: false });

  // Check cache validity
  const isCacheValid = feature.tddGuidance &&
    feature.tddGuidance.forVersion === feature.version;

  let guidance: TDDGuidance | CachedTDDGuidance;

  if (isCacheValid) {
    // Use cached AI guidance
    guidance = feature.tddGuidance;
    console.log(chalk.gray(`   (cached from ${feature.tddGuidance.generatedAt})`));
  } else {
    // Try AI generation
    const aiGuidance = await generateTDDGuidanceWithAI(feature, capabilities, cwd);

    if (aiGuidance) {
      // Save to feature list
      const featureList = await loadFeatureList(cwd);
      featureList.features = updateFeatureTDDGuidance(
        featureList.features,
        feature.id,
        aiGuidance
      );
      await saveFeatureList(cwd, featureList);
      guidance = aiGuidance;
    } else {
      // Fallback to regex-based
      guidance = generateTDDGuidance(feature, capabilities, cwd);
      console.log(chalk.yellow(`   (fallback: regex-based)`));
    }
  }

  // Display guidance
  displayTDDGuidance(guidance);
} catch (error) {
  // Silent fail for TDD guidance
}
```

### Step 5: Optional CLI Flag

**File:** `src/index.ts`

Add `--refresh-guidance` flag to force regeneration:

```typescript
.option("refresh-guidance", {
  type: "boolean",
  default: false,
  description: "Force regenerate TDD guidance",
})
```

## Files to Modify

| File | Action | Est. Lines |
|------|--------|------------|
| `src/types.ts` | Add `CachedTDDGuidance` interface | +25 |
| `src/types.ts` | Add `tddGuidance` to `Feature` | +5 |
| `src/tdd-ai-generator.ts` | **NEW** - AI generation logic | ~150 |
| `src/feature-list.ts` | Add `updateFeatureTDDGuidance()` | +10 |
| `src/index.ts` | Modify `runNext()` TDD section | ~50 |
| `tests/tdd-ai-generator.test.ts` | **NEW** - Unit tests | ~100 |

## Cache Invalidation

```
feature.tddGuidance.forVersion === feature.version
  -> true:  use cached
  -> false: regenerate with AI
```

When acceptance criteria changes, version increments, cache invalidates automatically.

## Testing Strategy

1. Unit test `generateTDDGuidanceWithAI()` with mocked agent responses
2. Integration test cache hit/miss logic
3. Test fallback behavior when AI unavailable
4. Test version-based invalidation

## Future Considerations

- Add more test frameworks as needed
- Consider storing guidance in separate `ai/guidance/` directory for large projects
- Add TTL-based expiration as optional enhancement
- Support custom prompt templates per project

---

*This RFC documents a proposed enhancement. Implementation is deferred for future work.*
