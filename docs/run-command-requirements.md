# `run` 命令需求说明

本文档描述在 `agent-foreman` 项目中新增 `run` 命令的功能需求和行为约束。`run` 用于执行由 `analyze` 命令生成的一系列 JSON 实现单元。

## 1. 命令形式与输入

- 新增 CLI 命令：`agent-foreman run <steps-dir>`
  - `<steps-dir>`：包含步骤 JSON 文件的目录路径，通常为 `analyze` 命令生成的 `<需求名字>需求实现步骤` 目录。
- 基本输入约束：
  - `<steps-dir>` 必须存在且为目录；
  - 目录中应包含至少一个 JSON 文件，否则应报错提示（例如：“步骤目录中未找到任何 JSON 步骤文件”）。

## 2. 步骤文件发现与排序

- `run` 在 `<steps-dir>` 中查找所有步骤 JSON 文件：
  - 首先枚举目录下所有以 `.json` 结尾的文件；
  - 将符合 `NNN-<slug>.json`（例如：`001-setup-auth.json`）的文件视为「步骤文件」；
  - 其余 `.json` 文件归类为「非步骤 JSON」，不会被当作步骤执行。
- 排序规则：
  - 对所有符合 `NNN-*.json` 规则的步骤文件按文件名进行字典序排序；
  - 排序后的顺序即为步骤的执行顺序。
- 健壮性与可观测性要求（与当前实现保持一致）：
  - 若目录中完全没有 `.json` 文件，应报错提示（例如：“步骤目录中未找到任何 JSON 步骤文件”）；
  - 若存在 `.json` 文件但没有任何一个符合 `NNN-*.json` 形式，应报错并在消息中列出发现的 JSON 文件名；
  - 若存在部分不符合 `NNN-*.json` 形式的 JSON 文件：
    - 这些文件会被跳过；
    - **必须在终端输出告警**，说明这些文件不会作为步骤执行，并列出它们的文件名，避免「悄悄跳过」。

## 3. 单个 JSON 步骤的解析与校验

对于排序后的每一个 JSON 文件，`run` 需要进行基本解析与结构校验：

- 解析 JSON 内容并检查必要字段：
  - `id`: 应为字符串，建议符合 `"step-001"` 这类形式；
  - `description`: 非空字符串；
  - `status`: 字符串，且只能是：
    - `"🔴 待完成"` / `"🟡 进行中"` / `"🟢 已完成"` 之一；
  - `verification`: 数组，数组元素应为对象，且至少包含：
    - `type`: 字符串（如 `unit` / `integration` / `ui` / `manual` 等）；
    - `description`: 字符串，对该验证项目的说明。
  - （可选）`unit_test` 字段，用于描述与该步骤强相关的测试命令：
    - `command`: 字符串，运行与本步骤相关测试的命令，例如：`"npm test -- tests/run-command.test.ts"`；
    - `files?`: 字符串数组，可选，列出主要覆盖的测试文件路径；
    - `notes?`: 字符串，可选，对测试范围或使用方式的补充说明。
- 如发现结构严重不合法（例如缺少核心字段、字段类型完全不匹配等），`run` 应：
  - 给出清晰错误信息（指出是哪个 JSON 文件有问题）；
  - 停止执行后续步骤。

> 备注：`run` 可以对 `id` 与文件名中的顺序号做一致性检查（例如 `step-001` 对应 `001-xxx.json`），如不一致可以警告或视为错误，具体细节在实现阶段再决定。

## 4. 步骤执行流程与 AI 进程约束

`run` 命令执行每个 JSON 步骤时，必须遵守「每次实现/验证调用都在独立的 AI 子进程中完成」这一约束：

- 对于每一个需要实现或验证的 JSON 步骤：
  - `run` 会在每一轮实现或验证时 **启动一个新的子进程**，调用命令行的 AI 工具；
  - 不会在同一个 AI 子进程内连续处理多个步骤，也不会在同一个子进程内混合多个步骤的实现。

### 4.1 单个步骤的多轮执行流程（普通 `run` 模式）

在普通 `run <steps-dir>` 模式下，对于 `status !== "🟢 已完成"` 的步骤，`run` 会在内部执行最多 5 轮「实现 + 测试 + verification」尝试。典型流程为：

1. 读取该 JSON 的 `id`、`description`、`status`、`verification`、`unit_test` 等信息；
2. 在每一轮尝试开始时：
   - 将该步骤的 `status` 更新为 `"🟡 进行中"` 并写回文件；
   - 在终端打印状态变化和本轮尝试序号；
   - 若是第 2 轮及以后，且上一轮失败，会在 prompt 中附带「上一轮失败原因摘要」。
3. 实现阶段：
   - `run` 利用 `callAnyAvailableAgent` 在新的 AI 子进程中执行实现逻辑：
     - Prompt 中包含步骤描述、`verification` 列表以及对 `unit_test` 输出格式的要求；
   - 若本轮实现失败（AI 子进程返回失败）：
     - 将 `status` 退回 `"🔴 待完成"`，记录失败原因（`aiError`）；
     - 写回 JSON，并更新进度报告；
     - 若当前尝试次数尚未达到上限（5 次），进入下一轮；否则终止本次 `run`。
   - 若本轮实现成功：
     - 将 `status` 更新为 `"🟢 已完成"` 并写回 JSON；
     - 尝试从 AI 输出中解析并写入 `unit_test` 字段。
4. 单元测试阶段（仅普通 `run` 模式）：
   - 如果步骤 JSON 中存在 `unit_test.command`：
     - 直接在当前项目根目录下执行该命令；
     - 若命令退出码为 0：视为单元测试通过；
     - 若退出码非 0：
       - 记录失败输出摘要；
       - 将 `status` 退回 `"🔴 待完成"`，写回 JSON 并更新进度报告；
       - 作为本轮失败原因写入下一轮实现的失败上下文；
       - 若未达到最大重试次数，继续下一轮；否则终止本次 `run`。
5. verification 阶段（仅普通 `run` 模式）：
   - 基于 `verification` 列表构造验证用的 prompt，通过 `callAnyAvailableAgent` 启动新的 AI 子进程执行「只验证不改代码」的逻辑；
   - 若验证失败：
     - 记录 `verificationError`，将 `status` 退回 `"🔴 待完成"`，写回 JSON 并更新进度报告；
     - 将错误信息写入下一轮实现的失败上下文；
     - 若未达到最大重试次数，继续下一轮；否则终止本次 `run`。
   - 若验证成功：
     - 保持 `status` 为 `"🟢 已完成"`；
     - 更新进度报告并结束当前步骤的多轮尝试。

### 4.2 `--full-verify` 模式下已完成步骤的处理

在 `run <steps-dir> --full-verify` 模式下，对于 `status === "🟢 已完成"` 的步骤，会额外执行一轮「仅测试 + 验证」的回归流程：

1. 若 JSON 中存在 `unit_test.command`：
   - 先执行该命令作为回归单元测试；
   - 若失败：记录错误并更新进度报告，将该步骤标记为需要重新实现（`needImplementation = true`）；
2. 若单元测试通过（或不存在）：
   - 通过 `callAnyAvailableAgent` 调用 AI 按 `verification` 列表进行验证；
   - 若验证失败：记录错误、更新进度报告，并将该步骤标记为需要重新实现。

对于在 full-verify 模式下被重新打开的步骤，后续会进入与普通模式相同的多轮实现逻辑；区别在于 full-verify 模式下，重新实现阶段不会再次自动执行单元测试和 verification，而是仅依赖实现成功与否。

### 4.3 进程隔离总结

- **每次实现或验证调用，对应一次命令行 AI 调用，对应一个独立 OS 子进程**；
- `run` 负责步骤调度、多轮重试和进度跟踪；
- 具体实现和验证细节由 AI 子进程根据 prompt 中的约定完成，包括生成/更新测试、运行 `unit_test.command` 所指定的测试命令等。

## 5. 执行顺序与失败处理策略

- 默认执行策略：
  - `run` 按排序后的文件名顺序，从第一个 JSON 步骤开始依次处理；
  - 对于每一个需要实现的步骤，内部最多尝试 5 轮「实现 + 测试 + verification」：
    - 如果在某一轮中实现成功且所有验证通过，则立即进入下一个步骤；
    - 如果连续 5 轮都无法通过（或在解析/写回 JSON 时遇到不可恢复的错误），则视为该步骤本次 `run` 失败。
  - 当某个步骤在最终尝试后仍然失败时：
    - `run` 会停止执行后续步骤；
    - 输出清晰的失败信息（包括第一个失败步骤的文件名、`id`、错误原因等）；
    - 在进度报告中将该步骤的结果标记为「失败」、后续未执行的步骤标记为「未执行」。
- 已完成步骤与 `--full-verify`：
  - 在默认模式下，`status === "🟢 已完成"` 的步骤不会重复执行实现逻辑，也不会自动重复测试和验证；
  - 在 `--full-verify` 模式下：
    - 会对已完成步骤额外运行一轮 `unit_test`（如存在）和 verification，用于回归验证；
    - 仅当回归测试或验证失败时，才会重新打开该步骤并进入多轮实现流程；
    - 若回归验证通过，则保持 `status` 为 `"🟢 已完成"` 并继续处理后续步骤。

## 6. 进度展示与进度跟踪文档

### 6.1 CLI 进度展示

`run` 在执行过程中需要在终端中清晰展示执行进度，方便用户观察当前执行到哪个步骤、整体完成情况等：

- 在开始执行前：
  - 输出整体信息，例如：
    - 发现了多少个步骤 JSON 文件；
    - 将按何种顺序执行（可简要打印前几项作为预览）。
- 对每一个步骤，在执行过程中至少需要输出：
  - 当前步骤的序号和总数（例如：`[2/5]`）；
  - JSON 文件名（例如：`002-setup-auth.json`）；
  - `id`（例如：`step-002`）；
  - `status` 变化（从 `"🔴 待完成"` → `"🟡 进行中"` → `"🟢 已完成"` 或失败时保持/恢复为 `"🔴 待完成"`）；
  - 简要的 `description` 摘要（可截断以避免输出过长）。
- 建议遵循项目现有的 CLI 风格（如使用 `chalk` 着色、简单的进度条或图标），但不强制具体样式。
- 在执行结束后：
  - 输出整体执行结果摘要，例如：
    - 总步骤数；
    - 成功的步骤数量；
    - 第一个失败步骤（如有）的文件名与 `id`；
    - 进度跟踪文档的保存路径（见下节）。

### 6.2 进度跟踪文档

`run` 在执行过程中需要生成一份「进度跟踪文档」，用于记录本次执行的详细过程和结果，并将其保存在执行目录中：

- 存放位置：
  - 进度跟踪文档保存在 `<steps-dir>` 目录下（即步骤 JSON 所在目录）；
  - 文件名固定为 `run-progress.md`，同一目录下在任意时刻只存在这一份报告；
  - 每次执行 `run` 都会覆盖/重写这份文档，以反映最近一次执行的结果。
- 文档格式：
  - 使用 Markdown 以便人类阅读和后续在 Git 中查看；
  - 至少包含以下信息：
    - 本次执行涉及的**所有步骤**（包括尚未开始执行、因中途中断而未执行到的步骤），而不仅仅是已尝试执行的步骤；
    - 本次 `run` 的开始时间和结束时间；
    - 使用的步骤目录路径（`<steps-dir>`）；
    - 总步骤数量；
    - 成功/失败步骤数量；
    - 对每个步骤的记录（可以用表格或分节形式），包括：
      - 顺序号（例如：`001`）；
      - JSON 文件名（例如：`001-setup-auth.json`）；
      - `id`（例如：`step-001`）；
      - 执行前状态与执行后状态（`status` 的变化），状态值需与 JSON 文件保持一致，使用带 emoji 的中文形式：
        - `"🔴 待完成"` / `"🟡 进行中"` / `"🟢 已完成"`；
      - 简要的 `description` 摘要；
      - AI 执行结果（成功/失败/未执行）；
      - 如有错误，则附上简短错误说明（例如子进程退出码、最近一次单元测试输出摘要或 verification 错误信息）。
- 更新时机：
  - 文档会在执行过程中多次重写，典型时机包括：
    - 解析步骤 JSON 失败或写回失败时；
    - 每轮单元测试失败或 verification 失败时；
    - 每轮验证成功后（包括 full-verify 场景）；
    - `run` 命令结束时的最终汇总；
  - 最终保证当 `run` 命令退出时，`run-progress.md` 始终准确反映本次执行中每个步骤的**最终结果**。
- 与现有日志/元数据的关系：
  - 此进度跟踪文档与现有的 `ai/progress.log` 等元数据文件完全独立；
  - 不需要复用或修改现有日志格式。

## 7. 与 `analyze` 的协作关系

- `analyze` 负责从需求文档生成结构化的实现步骤 JSON 文件；
- `run` 负责消费这些 JSON 文件，驱动命令行 AI 逐步完成实现与验证；
- 两者之间的协作约定：
  - `analyze` 输出的目录和文件结构必须符合 `docs/analyze-command-requirements.md` 中对 JSON 文件命名与结构的约定；
  - `run` 假定输入目录中存在这样的 JSON 文件，并按顺序调度执行；
  - 在执行时，`run` 遵守「每个 JSON 步骤一个新子进程调用命令行 AI」的约束，并结合 `verification` 信息要求 AI 生成并运行相应测试。
