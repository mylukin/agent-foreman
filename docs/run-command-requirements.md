# `run` 命令需求说明

本文档描述在 `agent-foreman` 项目中新增 `run` 命令的功能需求和行为约束。`run` 用于执行由 `analyze` 命令生成的一系列 JSON 实现单元。

## 1. 命令形式与输入

- 新增 CLI 命令：`agent-foreman run <steps-dir>`
  - `<steps-dir>`：包含步骤 JSON 文件的目录路径，通常为 `analyze` 命令生成的 `<需求名字>需求实现步骤` 目录。
- 基本输入约束：
  - `<steps-dir>` 必须存在且为目录；
  - 目录中应包含至少一个 JSON 文件，否则应报错提示（例如：“步骤目录中未找到任何 JSON 步骤文件”）。

## 2. 步骤文件发现与排序

- `run` 在 `<steps-dir>` 中查找所有步骤 JSON 文件：
  - 推荐命名形式为：`NNN-<slug>.json`（例如：`001-setup-auth.json`）；
  - 可以通过匹配 `*.json` 文件并按文件名过滤/排序来实现。
- 排序规则：
  - 按文件名进行字典序排序；
  - 排序后的顺序即为步骤的执行顺序。
- 健壮性要求：
  - 若发现文件名不符合 `NNN-*.json` 形式，可以选择：
    - 要么忽略这些文件；
    - 要么在实现中给出明确错误提示；
  - 具体处理策略可在实现阶段细化，但整体目标是：**不会悄悄跳过实际需要执行的步骤文件而不提示。**

## 3. 单个 JSON 步骤的解析与校验

对于排序后的每一个 JSON 文件，`run` 需要进行基本解析与结构校验：

- 解析 JSON 内容并检查必要字段：
  - `id`: 应为字符串，建议符合 `"step-001"` 这类形式；
  - `description`: 非空字符串；
  - `status`: 字符串，且只能是：
    - `"🔴 待完成"` / `"🟡 进行中"` / `"🟢 已完成"` 之一；
  - `verification`: 数组，数组元素应为对象，且至少包含：
    - `type`: 字符串（如 `unit` / `integration` / `ui` / `manual` 等）；
    - `description`: 字符串，对该验证项目的说明。
- 如发现结构严重不合法（例如缺少核心字段、字段类型完全不匹配等），`run` 应：
  - 给出清晰错误信息（指出是哪个 JSON 文件有问题）；
  - 停止执行后续步骤。

> 备注：`run` 可以对 `id` 与文件名中的顺序号做一致性检查（例如 `step-001` 对应 `001-xxx.json`），如不一致可以警告或视为错误，具体细节在实现阶段再决定。

## 4. 步骤执行流程与 AI 进程约束

`run` 命令执行每个 JSON 步骤时，必须遵守「每个 JSON 单独启动一个 AI 子进程」的约束：

- 对于每一个要执行的 JSON 步骤：
  - `run` 需要 **启动一个新的子进程**，调用命令行的 AI 工具来处理该 JSON；
  - 不允许在同一个 AI 子进程内连续处理多个步骤。
- 单个步骤的典型执行流程：
  1. `run` 读取该 JSON 的 `id`、`description`、`verification` 等信息；
  2. （可选）将该步骤的 `status` 更新为 `"🟡 进行中"` 并写回文件，以便在长任务中观察执行进度；
  3. `run` 利用现有的 agent 调用机制（如 `callAnyAvailableAgent`），在适当的工作目录下启动一个新的命令行 AI 子进程；
  4. 将步骤的上下文（包括 `description` 与 `verification` 列表等）通过 Prompt 或输入参数传给 AI，要求：
     - 根据 `description` 完成对应实现工作（代码修改、配置变更等）；
     - 根据 `verification` 列表为每个条目生成并运行相应的单元测试、集成测试或 UI 自动化测试；
  5. 等待子进程结束：
     - 若 AI 子进程以成功状态退出（例如退出码为 0，且在约定范围内未报告失败）：
       - 将该步骤的 `status` 更新为 `"🟢 已完成"` 并写回 JSON；
     - 若 AI 子进程失败（例如退出码非 0，或明确报告无法完成/测试失败）：
       - 将该步骤的 `status` 更新为 `"🔴 待完成"`（或保持失败前状态，具体策略可在实现阶段细化）；
       - 记录错误信息并终止后续步骤执行。

- 进程隔离要求总结：
  - **一个 JSON 步骤，对应一次命令行 AI 调用，对应一个独立 OS 子进程**；
  - `run` 负责步骤调度与过程控制，而具体实现和测试生成/执行由 AI 进程负责。

## 5. 执行顺序与失败处理策略

- 默认执行策略：
  - `run` 按排序后的文件名顺序，从第一个 JSON 步骤开始依次执行；
  - 当某个步骤执行失败时（AI 子进程失败或 JSON 结构不合法等）：
    - `run` 应停止执行后续步骤；
    - 输出清晰的失败信息（包括失败步骤的文件名、`id`、错误原因等）。
- 默认情况下，`run` 不对 `status` 做「自动跳过」逻辑：
  - 即使某个步骤的 `status` 已经是 `"🟢 已完成"`，再次执行 `run` 时仍然会依次执行各步骤；
  - 这样可以用于「回归执行」或「重新验证」；
  - 将来如有需要，可以通过额外选项（例如 `--resume`、`--skip-completed`）扩展「跳过已完成步骤」等行为，但不属于本版必需需求。

## 6. 进度展示与进度跟踪文档

### 6.1 CLI 进度展示

`run` 在执行过程中需要在终端中清晰展示执行进度，方便用户观察当前执行到哪个步骤、整体完成情况等：

- 在开始执行前：
  - 输出整体信息，例如：
    - 发现了多少个步骤 JSON 文件；
    - 将按何种顺序执行（可简要打印前几项作为预览）。
- 对每一个步骤，在执行过程中至少需要输出：
  - 当前步骤的序号和总数（例如：`[2/5]`）；
  - JSON 文件名（例如：`002-setup-auth.json`）；
  - `id`（例如：`step-002`）；
  - `status` 变化（从 `"🔴 待完成"` → `"🟡 进行中"` → `"🟢 已完成"` 或失败时保持/恢复为 `"🔴 待完成"`）；
  - 简要的 `description` 摘要（可截断以避免输出过长）。
- 建议遵循项目现有的 CLI 风格（如使用 `chalk` 着色、简单的进度条或图标），但不强制具体样式。
- 在执行结束后：
  - 输出整体执行结果摘要，例如：
    - 总步骤数；
    - 成功的步骤数量；
    - 第一个失败步骤（如有）的文件名与 `id`；
    - 进度跟踪文档的保存路径（见下节）。

### 6.2 进度跟踪文档

`run` 在执行过程中需要生成一份「进度跟踪文档」，用于记录本次执行的详细过程和结果，并将其保存在执行目录中：

- 存放位置：
  - 进度跟踪文档应保存在 `<steps-dir>` 目录下（即步骤 JSON 所在目录）；
  - 每次执行 `run` 生成一份新的文档，避免覆盖历史记录。
- 文件命名建议：
  - 例如：`run-progress-YYYYMMDD-HHMMSS.md` 或类似带时间戳的命名；
  - 具体格式可在实现时按项目习惯确定，但需保证同一目录下多次执行不会互相覆盖。
- 文档格式：
  - 使用 Markdown 以便人类阅读和后续在 Git 中查看；
  - 至少包含以下信息：
    - 本次执行涉及的**所有步骤**（包括尚未开始执行、因中途中断而未执行到的步骤），而不仅仅是已尝试执行的步骤；
    - 本次 `run` 的开始时间和结束时间；
    - 使用的步骤目录路径（`<steps-dir>`）；
    - 总步骤数量；
    - 成功/失败步骤数量；
    - 对每个步骤的记录（可以用表格或分节形式），包括：
      - 顺序号（例如：`001`）；
      - JSON 文件名（例如：`001-setup-auth.json`）；
      - `id`（例如：`step-001`）；
      - 执行前状态与执行后状态（`status` 的变化），状态值需与 JSON 文件保持一致，使用带 emoji 的中文形式：
        - `"🔴 待完成"` / `"🟡 进行中"` / `"🟢 已完成"`；
      - 简要的 `description` 摘要；
      - AI 执行结果（成功/失败）；
      - 如有错误，则附上简短错误说明（例如子进程退出码或关键信息）。
- 更新时机：
  - 文档应在执行过程中逐步更新或在执行结束后一次性写出；
  - 最终保证当 `run` 命令退出时，该文档处于一致状态，准确反映本次执行结果。
- 与现有日志/元数据的关系：
  - 此进度跟踪文档与现有的 `ai/progress.log` 等元数据文件完全独立；
  - 不需要复用或修改现有日志格式。

## 7. 与 `analyze` 的协作关系

- `analyze` 负责从需求文档生成结构化的实现步骤 JSON 文件；
- `run` 负责消费这些 JSON 文件，驱动命令行 AI 逐步完成实现与验证；
- 两者之间的协作约定：
  - `analyze` 输出的目录和文件结构必须符合 `docs/analyze-command-requirements.md` 中对 JSON 文件命名与结构的约定；
  - `run` 假定输入目录中存在这样的 JSON 文件，并按顺序调度执行；
  - 在执行时，`run` 遵守「每个 JSON 步骤一个新子进程调用命令行 AI」的约束，并结合 `verification` 信息要求 AI 生成并运行相应测试。
