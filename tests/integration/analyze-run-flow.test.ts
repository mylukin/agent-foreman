/**
 * Integration tests for end-to-end analyze â†’ run flow
 *
 * These tests verify that:
 * - `agent-foreman analyze` generates a steps directory with valid JSON step files
 * - `agent-foreman run` can consume those JSON files without being sensitive
 *   to the internal analyze output format (id, filename, status, verification)
 * - Status values flow from ğŸ”´ å¾…å®Œæˆ â†’ ğŸŸ¡ è¿›è¡Œä¸­ â†’ ğŸŸ¢ å·²å®Œæˆ and are reflected
 *   correctly in the run-progress markdown report.
 */
import { describe, it, expect, beforeEach, afterEach } from "vitest";
import { spawnSync } from "node:child_process";
import * as fs from "node:fs/promises";
import * as path from "node:path";
import * as os from "node:os";

// Path to the built CLI entrypoint
const CLI_PATH = path.resolve(process.cwd(), "dist/index.js");

// On Windows we skip these tests because the fake agent script is POSIX-only
const isWindows = process.platform === "win32";
const testOrSkip = isWindows ? it.skip : it;

async function createTempProjectDir(prefix: string): Promise<string> {
  return fs.mkdtemp(path.join(os.tmpdir(), prefix));
}

async function createFakeAnalyzeAndRunAgent(binDir: string): Promise<string> {
  const scriptPath = path.join(binDir, "codex");
  const scriptContent = [
    "#!/bin/sh",
    "# Fake codex agent used for analyze+run integration tests.",
    "# It inspects the incoming prompt on stdin to decide whether it is the",
    "# requirement-name phase or the steps phase for `analyze`.",
    "",
    "# If stdin contains an example JSON with a \"steps\" field, we treat it",
    "# as the steps-generation phase and return steps JSON. Otherwise we",
    "# return a simple requirementName JSON. For `run` prompts we only care",
    "# about the exit code, so they can also take the requirementName branch.",
    "if grep -q '\"steps\"'; then",
    "  echo '{\"steps\":[{\"slug\":\"first-step\",\"description\":\"First test step generated by fake agent.\",\"completion\":\"todo\",\"verification\":[{\"type\":\"integration\",\"description\":\"Verify run can execute first step.\"}]},{\"slug\":\"second-step\",\"description\":\"Second test step for analyze+run flow.\",\"completion\":\"todo\",\"verification\":[{\"type\":\"integration\",\"description\":\"Verify run handles multiple steps.\"}]}]}'",
    "else",
    "  # Requirement-name phase or any other prompt: return a simple name JSON",
    "  echo '{\"requirementName\":\"Analyze+Run æµ‹è¯•éœ€æ±‚\"}'",
    "fi",
    "",
    "# For run-command usage we only care about the exit code being 0/1.",
    "# Here we always exit 0 so that steps are treated as successful.",
    "exit 0",
    "",
  ].join("\n");

  await fs.writeFile(scriptPath, scriptContent, "utf-8");
  await fs.chmod(scriptPath, 0o755);
  return scriptPath;
}

describe("CLI analyze + run flow (integration)", () => {
  const tempRoots: string[] = [];

  beforeEach(() => {
    // Ensure we don't leak exitCode from previous runs
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    (process as any).exitCode = undefined;
  });

  afterEach(async () => {
    // Best-effort cleanup of temporary directories
    for (const dir of tempRoots) {
      try {
        await fs.rm(dir, { recursive: true, force: true });
      } catch {
        // ignore cleanup errors
      }
    }
    tempRoots.length = 0;
  });

  testOrSkip("[integration] analyze output can be consumed by run end-to-end", async () => {
    const rootDir = await createTempProjectDir("foreman-analyze-run-");
    tempRoots.push(rootDir);

    // Minimal requirement spec for analyze to consume
    const specPath = path.join(rootDir, "spec.md");
    await fs.writeFile(
      specPath,
      "# Analyze + Run æµ‹è¯•éœ€æ±‚\n\nè¿™æ˜¯ä¸€ä¸ªç”¨äºéªŒè¯ analyze ä¸ run ç«¯åˆ°ç«¯æµç¨‹çš„æœ€å°éœ€æ±‚æ–‡æ¡£ã€‚",
      "utf-8",
    );

    // Prepare fake agent script
    const binDir = path.join(rootDir, "bin");
    await fs.mkdir(binDir, { recursive: true });
    await createFakeAnalyzeAndRunAgent(binDir);

    const env = {
      ...process.env,
      AGENT_FOREMAN_AGENTS: "codex",
      // Ensure our fake agent is found before any real agents, and keep /usr/bin for `which`
      PATH: `${binDir}${path.delimiter}/usr/bin`,
    };

    // 1) Run `agent-foreman analyze <spec>` to generate steps directory and JSON files
    const analyzeResult = spawnSync(process.execPath, [CLI_PATH, "analyze", specPath], {
      cwd: rootDir,
      encoding: "utf-8",
      env,
    });

    expect(analyzeResult.status, analyzeResult.stderr || analyzeResult.stdout).toBe(0);

    // Discover the generated steps directory (<éœ€æ±‚åå­—>éœ€æ±‚å®ç°æ­¥éª¤)
    const rootEntries = await fs.readdir(rootDir, { withFileTypes: true });
    const stepsDirEntry = rootEntries.find(
      (entry) => entry.isDirectory() && entry.name.endsWith("éœ€æ±‚å®ç°æ­¥éª¤"),
    );

    expect(stepsDirEntry).toBeDefined();
    const stepsDir = path.join(rootDir, stepsDirEntry!.name);

    // The directory should contain multiple NNN-*.json step files generated from the fake agent
    const stepFiles = (await fs.readdir(stepsDir)).filter((f) =>
      /^\d{3}-.+\.json$/.test(f),
    );
    expect(stepFiles.length).toBeGreaterThanOrEqual(2);

    stepFiles.sort();
    const firstStepPath = path.join(stepsDir, stepFiles[0]);
    const firstStep = JSON.parse(await fs.readFile(firstStepPath, "utf-8"));

    // Verify analyze produced correct id, initial status, and verification list
    expect(firstStep.id).toBe("step-001");
    expect(firstStep.status).toBe("ğŸ”´ å¾…å®Œæˆ");
    expect(Array.isArray(firstStep.verification)).toBe(true);
    expect(firstStep.verification.length).toBeGreaterThan(0);

    // 2) Run `agent-foreman run <steps-dir>` to consume the generated JSON steps
    const runResult = spawnSync(process.execPath, [CLI_PATH, "run", stepsDir], {
      cwd: rootDir,
      encoding: "utf-8",
      env,
    });

    expect(runResult.status, runResult.stderr || runResult.stdout).toBe(0);
    expect(runResult.stdout).toContain("ğŸ“‹ æœ¬æ¬¡ run æ‰§è¡Œç»“æœï¼š");

    // All step files should now be marked as completed
    const finalStepFiles = (await fs.readdir(stepsDir)).filter((f) =>
      /^\d{3}-.+\.json$/.test(f),
    );
    expect(finalStepFiles.length).toBe(stepFiles.length);

    for (const file of finalStepFiles) {
      const content = JSON.parse(
        await fs.readFile(path.join(stepsDir, file), "utf-8"),
      );
      expect(content.status).toBe("ğŸŸ¢ å·²å®Œæˆ");
    }

    // A run-progress markdown report should be generated alongside the steps
    const progressFiles = (await fs.readdir(stepsDir)).filter(
      (f) => f.startsWith("run-progress") && f.endsWith(".md"),
    );
    expect(progressFiles.length).toBe(1);

    const progressPath = path.join(stepsDir, progressFiles[0]);
    const progressContent = await fs.readFile(progressPath, "utf-8");

    // The report should list all steps and reflect status transitions and success results
    for (const file of finalStepFiles) {
      const row = progressContent
        .split("\n")
        .find((line) => line.includes(file));
      expect(row, `Missing row for ${file} in run-progress report`).toBeDefined();
      // æ‰§è¡Œå‰çŠ¶æ€åˆ—åº”åŒ…å«å¾…å®Œæˆï¼Œæ‰§è¡ŒåçŠ¶æ€åˆ—åº”åŒ…å«å·²å®Œæˆï¼Œç»“æœåˆ—åº”æ ‡è®°ä¸ºæˆåŠŸ
      expect(row as string).toContain("ğŸ”´ å¾…å®Œæˆ");
      expect(row as string).toContain("ğŸŸ¢ å·²å®Œæˆ");
      expect(row as string).toContain("æˆåŠŸ");
    }
  });
});
