/**
 * Prompt templates for CLAUDE.md and other documentation
 */

/**
 * Generate minimal CLAUDE.md content for a project
 *
 * This is the NEW approach where rules are stored in .claude/rules/ directory.
 * CLAUDE.md only contains project-specific content (goal).
 * Claude Code automatically loads all .md files from .claude/rules/ as project memory.
 */
export function generateMinimalClaudeMd(goal: string): string {
  return `# Project Instructions

## Project Goal

${goal}

---

*This project uses agent-foreman. Rules are loaded from .claude/rules/*
*Generated by agent-foreman - https://github.com/mylukin/agent-foreman*
`;
}

/**
 * Generate a commit message template
 */
export function generateCommitMessage(
  featureId: string,
  description: string,
  summary: string
): string {
  return `feat(${featureId.split(".")[0]}): ${description}

${summary}

Feature: ${featureId}

ğŸ¤– Generated with agent-foreman`;
}

/**
 * Generate feature step guidance
 */
export function generateFeatureGuidance(feature: {
  id: string;
  description: string;
  acceptance: string[];
  dependsOn: string[];
  notes: string;
}): string {
  const lines: string[] = [];

  lines.push(`## Feature: ${feature.id}`);
  lines.push("");
  lines.push(`**Description:** ${feature.description}`);
  lines.push("");
  lines.push("### Acceptance Criteria");
  lines.push("");
  for (const [i, criteria] of feature.acceptance.entries()) {
    lines.push(`${i + 1}. [ ] ${criteria}`);
  }

  if (feature.dependsOn.length > 0) {
    lines.push("");
    lines.push("### Dependencies");
    lines.push("");
    lines.push("Ensure these features are passing first:");
    for (const dep of feature.dependsOn) {
      lines.push(`- ${dep}`);
    }
  }

  if (feature.notes) {
    lines.push("");
    lines.push("### Notes");
    lines.push("");
    lines.push(feature.notes);
  }

  lines.push("");
  lines.push("### Workflow");
  lines.push("");
  lines.push("1. Review acceptance criteria above");
  lines.push("2. Implement the feature");
  lines.push(`3. Run \`agent-foreman check ${feature.id}\` to verify implementation`);
  lines.push(`4. Run \`agent-foreman done ${feature.id}\` to mark complete + commit`);

  return lines.join("\n");
}

/**
 * Generate impact review guidance
 */
export function generateImpactGuidance(
  changedFeature: string,
  affectedFeatures: { id: string; reason: string }[]
): string {
  const lines: string[] = [];

  lines.push(`## Impact Review: ${changedFeature}`);
  lines.push("");

  if (affectedFeatures.length === 0) {
    lines.push("No other features are affected by this change.");
    return lines.join("\n");
  }

  lines.push("The following features may be affected by this change:");
  lines.push("");
  lines.push("| Feature | Reason | Action |");
  lines.push("|---------|--------|--------|");

  for (const f of affectedFeatures) {
    lines.push(`| ${f.id} | ${f.reason} | Review and update status |`);
  }

  lines.push("");
  lines.push("### Recommended Actions");
  lines.push("");
  lines.push("1. Review each affected feature");
  lines.push("2. Run tests for affected modules");
  lines.push("3. Mark as `needs_review` if uncertain");
  lines.push("4. Update `notes` field with impact details");

  return lines.join("\n");
}

/**
 * Generate session summary
 */
export function generateSessionSummary(
  completed: { id: string; description: string }[],
  remaining: { id: string; priority: number }[],
  nextFeature: { id: string; description: string } | null
): string {
  const lines: string[] = [];

  lines.push("## Session Summary");
  lines.push("");

  if (completed.length > 0) {
    lines.push("### Completed This Session");
    for (const f of completed) {
      lines.push(`- âœ… ${f.id}: ${f.description}`);
    }
    lines.push("");
  }

  lines.push(`### Remaining: ${remaining.length} features`);
  lines.push("");

  if (nextFeature) {
    lines.push("### Next Up");
    lines.push(`**${nextFeature.id}**: ${nextFeature.description}`);
  } else {
    lines.push("ğŸ‰ All features are complete!");
  }

  return lines.join("\n");
}
