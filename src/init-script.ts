/**
 * Generate ai/init.sh bootstrap script
 */
import type { ProjectCommands } from "./types.js";
import type { ExtendedCapabilities } from "./verification-types.js";

/**
 * Get install command based on package manager
 */
function getInstallCommand(packageManager?: string): string {
  switch (packageManager) {
    case "pnpm":
      return "pnpm install";
    case "yarn":
      return "yarn install";
    case "bun":
      return "bun install";
    case "pip":
      return "pip install -r requirements.txt";
    case "cargo":
      return "cargo build";
    case "go":
      return "go mod download";
    case "npm":
    default:
      return "npm install";
  }
}

/**
 * Get dev command based on package manager
 */
function getDevCommand(packageManager?: string): string {
  switch (packageManager) {
    case "pnpm":
      return "pnpm dev";
    case "yarn":
      return "yarn dev";
    case "bun":
      return "bun dev";
    case "cargo":
      return "cargo run";
    case "go":
      return "go run .";
    case "npm":
    default:
      return "npm run dev";
  }
}

/**
 * Fallback commands interface for generateInitScriptFromCapabilities
 */
export interface FallbackCommands {
  install?: string;
  dev?: string;
}

/**
 * E2E commands interface for init.sh generation
 */
export interface E2ECommands {
  /** Base E2E test command (e.g., "npx playwright test") */
  command?: string;
  /** Grep template for tag filtering (e.g., "npx playwright test --grep {tags}") */
  grepTemplate?: string;
}

/**
 * Generate init.sh script from ExtendedCapabilities
 * This is the primary function for generating init.sh from capabilities detection
 */
export function generateInitScriptFromCapabilities(
  caps: ExtendedCapabilities,
  fallbackCommands?: FallbackCommands
): string {
  const packageManager = caps.testInfo?.packageManager;

  const commands: ProjectCommands = {
    install: fallbackCommands?.install || getInstallCommand(packageManager),
    dev: fallbackCommands?.dev || getDevCommand(packageManager),
    build: caps.buildCommand || "",
    test: caps.testCommand || "",
    lint: caps.lintCommand,
  };

  // Extract E2E commands from capabilities
  const e2eCommands: E2ECommands | undefined = caps.e2eInfo?.available
    ? {
        command: caps.e2eInfo.command,
        grepTemplate: caps.e2eInfo.grepTemplate,
      }
    : undefined;

  // Use capabilities typeCheckCommand instead of hardcoded "npx tsc --noEmit"
  return generateInitScriptWithTypeCheck(commands, caps.typeCheckCommand, e2eCommands);
}

/**
 * Build E2E test section for init.sh
 * Generates bash code that handles E2E testing with mode support
 */
function buildE2ESection(e2eCommands: E2ECommands): string {
  const baseCommand = e2eCommands.command || "npx playwright test";
  const grepTemplate = e2eCommands.grepTemplate || `${baseCommand} --grep {tags}`;

  return `# Run E2E tests based on mode
    # CI=true ensures Playwright runs in CI mode (no interactive prompts, proper exit codes)
    if [ "\$skip_e2e" = true ]; then
      log_info "E2E tests: skipped (--skip-e2e)"
    elif [ "\$full_mode" = true ]; then
      log_info "Running E2E tests (full)..."
      if ! CI=true ${baseCommand}; then
        log_error "E2E tests failed"
        e2e_exit_code=1
      fi
    elif [ -n "\$e2e_tags" ]; then
      log_info "Running E2E tests (tags: \$e2e_tags)..."
      local e2e_cmd="CI=true ${grepTemplate.replace("{tags}", "\\$e2e_tags")}"
      if ! eval "\$e2e_cmd"; then
        log_error "E2E tests failed"
        e2e_exit_code=1
      fi
    else
      log_info "Running E2E tests (@smoke)..."
      if ! CI=true ${grepTemplate.replace("{tags}", "@smoke")}; then
        log_error "E2E tests failed"
        e2e_exit_code=1
      fi
    fi`;
}

/**
 * Generate init.sh with explicit typecheck command support and E2E test support
 */
export function generateInitScriptWithTypeCheck(
  commands: ProjectCommands,
  typeCheckCommand?: string,
  e2eCommands?: E2ECommands
): string {
  // Build typecheck section based on provided command
  const typeCheckSection = typeCheckCommand
    ? `log_info "Running type check..."
    if ! ${typeCheckCommand}; then
      log_error "Type check failed"
      exit_code=1
    fi`
    : `# Run type check if TypeScript detected
    if [ -f "tsconfig.json" ]; then
      log_info "Running type check..."
      if ! npx tsc --noEmit; then
        log_error "Type check failed"
        exit_code=1
      fi
    fi`;

  // Build E2E test section if E2E commands are available
  const e2eSection = e2eCommands?.command
    ? buildE2ESection(e2eCommands)
    : "# No E2E tests configured";

  return `#!/usr/bin/env bash
# ai/init.sh - Bootstrap script for agent-foreman harness
# Generated by agent-foreman
set -euo pipefail

# Colors for output
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
NC='\\033[0m' # No Color

log_info() {
  echo -e "\${GREEN}[INFO]\${NC} \$1"
}

log_warn() {
  echo -e "\${YELLOW}[WARN]\${NC} \$1"
}

log_error() {
  echo -e "\${RED}[ERROR]\${NC} \$1"
}

# Bootstrap: Install dependencies
bootstrap() {
  log_info "Installing dependencies..."
  ${commands.install || "echo 'No install command configured'"}
  log_info "Bootstrap complete!"
}

# Dev: Start development environment
dev() {
  log_info "Starting development server..."
  ${commands.dev || "echo 'No dev command configured'"}
}

# Check: Run all verification checks (tests, types, lint, build, e2e)
# Usage: check [--quick] [--full] [--skip-e2e] [test_pattern]
# Environment: E2E_TAGS - comma-separated tags for E2E filtering in quick mode
check() {
  local exit_code=0
  local e2e_exit_code=0
  local quick_mode=false
  local full_mode=false
  local skip_e2e=false
  local test_pattern=""
  local e2e_tags="\${E2E_TAGS:-}"

  # Parse arguments
  while [[ \$# -gt 0 ]]; do
    case "\$1" in
      --quick)
        quick_mode=true
        shift
        ;;
      --full)
        full_mode=true
        shift
        ;;
      --skip-e2e)
        skip_e2e=true
        shift
        ;;
      *)
        test_pattern="\$1"
        shift
        ;;
    esac
  done

  if [ "\$full_mode" = true ]; then
    log_info "Running checks (full mode)..."
  elif [ "\$quick_mode" = true ]; then
    log_info "Running checks (quick mode)..."
  else
    log_info "Running checks..."
  fi

  # Run unit tests if available
  # CI=true disables watch mode in Vitest/Jest and ensures single-run execution
  ${commands.test ? `log_info "Running unit tests..."
  if [ -n "\$test_pattern" ]; then
    log_info "Test pattern: \$test_pattern"
    if ! CI=true ${commands.test} "\$test_pattern"; then
      log_error "Unit tests failed"
      exit_code=1
    fi
  else
    if ! CI=true ${commands.test}; then
      log_error "Unit tests failed"
      exit_code=1
    fi
  fi` : "log_warn \"No test command configured\""}

  # In quick mode, skip type check, lint, and build
  if [ "\$quick_mode" = true ]; then
    log_info "Quick mode: skipping type check, lint, and build"
  else
    ${typeCheckSection}

    # Run lint if available
    ${commands.lint ? `log_info "Running linter..."
    if ! ${commands.lint}; then
      log_error "Lint failed"
      exit_code=1
    fi` : ""}

    # Run build if available
    ${commands.build ? `log_info "Running build..."
    if ! ${commands.build}; then
      log_error "Build failed"
      exit_code=1
    fi` : ""}
  fi

  # Run E2E tests (after unit tests)
  ${e2eSection}

  # Report final status
  if [ \$exit_code -eq 0 ] && [ \$e2e_exit_code -eq 0 ]; then
    log_info "All checks passed!"
  else
    if [ \$exit_code -ne 0 ]; then
      log_error "Unit tests/checks failed"
    fi
    if [ \$e2e_exit_code -ne 0 ]; then
      log_error "E2E tests failed"
    fi
  fi

  # Return combined exit code
  return \$(( exit_code + e2e_exit_code ))
}

# Build: Build for production
build() {
  log_info "Building for production..."
  ${commands.build || "echo 'No build command configured'"}
  log_info "Build complete!"
}

# Status: Show project status
status() {
  log_info "Project Status"
  echo "---"

  # Show feature list status if exists (check new format first, then legacy)
  if [ -f "ai/features/index.json" ]; then
    echo "Feature Index: ai/features/index.json"
    local total=$(jq '.features | keys | length' ai/features/index.json)
    local passing=$(jq '[.features | to_entries[] | select(.value.status == "passing")] | length' ai/features/index.json)
    local failing=$(jq '[.features | to_entries[] | select(.value.status == "failing")] | length' ai/features/index.json)
    local review=$(jq '[.features | to_entries[] | select(.value.status == "needs_review")] | length' ai/features/index.json)
    echo "  Total: \$total"
    echo "  Passing: \$passing"
    echo "  Failing: \$failing"
    echo "  Needs Review: \$review"
  elif [ -f "ai/feature_list.json" ]; then
    echo "Feature List (legacy): ai/feature_list.json"
    local total=$(jq '.features | length' ai/feature_list.json)
    local passing=$(jq '[.features[] | select(.status == "passing")] | length' ai/feature_list.json)
    local failing=$(jq '[.features[] | select(.status == "failing")] | length' ai/feature_list.json)
    local review=$(jq '[.features[] | select(.status == "needs_review")] | length' ai/feature_list.json)
    echo "  Total: \$total"
    echo "  Passing: \$passing"
    echo "  Failing: \$failing"
    echo "  Needs Review: \$review"
  else
    log_warn "No feature list found. Run 'agent-foreman init' first."
  fi

  # Show recent progress log entries
  if [ -f "ai/progress.log" ]; then
    echo ""
    echo "Recent Progress:"
    tail -5 ai/progress.log
  fi
}

# Help
show_help() {
  echo "Usage: ./ai/init.sh <command> [options]"
  echo ""
  echo "Commands:"
  echo "  bootstrap           Install dependencies"
  echo "  dev                 Start development server"
  echo "  check [options]     Run all checks (tests, types, lint, build, e2e)"
  echo "    --quick           Run only unit tests + E2E by E2E_TAGS (or @smoke)"
  echo "    --full            Run all tests including full E2E suite"
  echo "    --skip-e2e        Skip E2E tests entirely (unit tests only)"
  echo "  build               Build for production"
  echo "  status              Show project status"
  echo "  help                Show this help message"
  echo ""
  echo "Environment:"
  echo "  E2E_TAGS            Tags for E2E filtering in quick mode (e.g., @feature-auth)"
}

# Main entry point
case "\${1:-help}" in
  bootstrap)
    bootstrap
    ;;
  dev)
    dev
    ;;
  check)
    shift
    check "\$@"
    ;;
  build)
    build
    ;;
  status)
    status
    ;;
  help|--help|-h)
    show_help
    ;;
  *)
    log_error "Unknown command: \$1"
    show_help
    exit 1
    ;;
esac
`;
}

/**
 * Generate init.sh script content
 * @deprecated Use generateInitScriptFromCapabilities for new code
 */
export function generateInitScript(commands: ProjectCommands): string {
  // Delegate to the new function without explicit typecheck command (uses fallback detection)
  return generateInitScriptWithTypeCheck(commands);
}

/**
 * Generate minimal init.sh for projects without detected commands
 */
export function generateMinimalInitScript(): string {
  return `#!/usr/bin/env bash
# ai/init.sh - Bootstrap script for agent-foreman harness
# Generated by agent-foreman
set -euo pipefail

# Colors for output
RED='\\033[0;31m'
GREEN='\\033[0;32m'
YELLOW='\\033[1;33m'
NC='\\033[0m' # No Color

log_info() {
  echo -e "\${GREEN}[INFO]\${NC} \$1"
}

log_warn() {
  echo -e "\${YELLOW}[WARN]\${NC} \$1"
}

log_error() {
  echo -e "\${RED}[ERROR]\${NC} \$1"
}

# Bootstrap: Install dependencies
bootstrap() {
  log_info "Installing dependencies..."
  # TODO: Add your install command
  echo "Please configure install command in this script"
}

# Dev: Start development environment
dev() {
  log_info "Starting development server..."
  # TODO: Add your dev command
  echo "Please configure dev command in this script"
}

# Check: Run all verification checks (tests, types, lint, build)
# Usage: check [--quick] [test_pattern]
check() {
  local exit_code=0
  local quick_mode=false
  local test_pattern=""

  # Parse arguments
  while [[ \$# -gt 0 ]]; do
    case "\$1" in
      --quick)
        quick_mode=true
        shift
        ;;
      *)
        test_pattern="\$1"
        shift
        ;;
    esac
  done

  if [ "\$quick_mode" = true ]; then
    log_info "Running checks (quick mode)..."
  else
    log_info "Running checks..."
  fi

  # TODO: Configure test command
  log_warn "Configure test/lint/build commands for full verification"

  # In quick mode, skip type check, lint, and build
  if [ "\$quick_mode" = true ]; then
    log_info "Quick mode: skipping type check, lint, and build"
  else
    # Run type check if TypeScript detected
    if [ -f "tsconfig.json" ]; then
      log_info "Running type check..."
      if ! npx tsc --noEmit; then
        log_error "Type check failed"
        exit_code=1
      fi
    fi
  fi

  if [ \$exit_code -eq 0 ]; then
    log_info "All checks passed!"
  else
    log_error "Some checks failed"
  fi

  return \$exit_code
}

# Build: Build for production
build() {
  log_info "Building for production..."
  # TODO: Add your build command
  echo "Please configure build command in this script"
}

# Status: Show project status
status() {
  log_info "Project Status"
  echo "---"

  # Check new format first, then legacy
  if [ -f "ai/features/index.json" ]; then
    echo "Feature Index: ai/features/index.json"
    if command -v jq &> /dev/null; then
      local total=$(jq '.features | keys | length' ai/features/index.json)
      local passing=$(jq '[.features | to_entries[] | select(.value.status == "passing")] | length' ai/features/index.json)
      echo "  Total: \$total"
      echo "  Passing: \$passing"
    fi
  elif [ -f "ai/feature_list.json" ]; then
    echo "Feature List (legacy): ai/feature_list.json"
    if command -v jq &> /dev/null; then
      local total=$(jq '.features | length' ai/feature_list.json)
      local passing=$(jq '[.features[] | select(.status == "passing")] | length' ai/feature_list.json)
      echo "  Total: \$total"
      echo "  Passing: \$passing"
    fi
  else
    log_warn "No feature list found. Run 'agent-foreman init' first."
  fi
}

# Help
show_help() {
  echo "Usage: ./ai/init.sh <command> [options]"
  echo ""
  echo "Commands:"
  echo "  bootstrap           Install dependencies"
  echo "  dev                 Start development server"
  echo "  check [options]     Run all checks (tests, types, lint, build, e2e)"
  echo "    --quick           Run only unit tests + E2E by E2E_TAGS (or @smoke)"
  echo "    --full            Run all tests including full E2E suite"
  echo "    --skip-e2e        Skip E2E tests entirely (unit tests only)"
  echo "  build               Build for production"
  echo "  status              Show project status"
  echo "  help                Show this help message"
  echo ""
  echo "Environment:"
  echo "  E2E_TAGS            Tags for E2E filtering in quick mode (e.g., @feature-auth)"
}

# Main entry point
case "\${1:-help}" in
  bootstrap)
    bootstrap
    ;;
  dev)
    dev
    ;;
  check)
    shift
    check "\$@"
    ;;
  build)
    build
    ;;
  status)
    status
    ;;
  help|--help|-h)
    show_help
    ;;
  *)
    log_error "Unknown command: \$1"
    show_help
    exit 1
    ;;
esac
`;
}
