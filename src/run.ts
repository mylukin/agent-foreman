/**
 * Implementation of `run` command
 * Executes JSON step files generated by `analyze` command
 */
import * as fs from "node:fs/promises";
import * as path from "node:path";
import { spawnSync } from "node:child_process";
import chalk from "chalk";
import { callAnyAvailableAgent } from "./agents.js";
import { extractJsonObject, type VerificationItem } from "./analyze.js";

export type StepStatus = "ğŸ”´ å¾…å®Œæˆ" | "ğŸŸ¡ è¿›è¡Œä¸­" | "ğŸŸ¢ å·²å®Œæˆ";

export interface StepUnitTest {
  command: string;
  files?: string[];
  notes?: string;
}

export interface StepJson {
  id: string;
  description: string;
  status: StepStatus;
  verification: VerificationItem[];
  unit_test?: StepUnitTest;
  // Allow extra fields for forward compatibility
  [key: string]: unknown;
}

interface RunStepEntry {
  order: number;
  prefix: string;
  fileName: string;
  filePath: string;
  id?: string;
  description?: string;
  initialStatus?: StepStatus;
  finalStatus?: StepStatus;
  verification?: VerificationItem[];
  unitTest?: StepUnitTest;
  parseError?: string;
  success?: boolean;
  error?: string;
}

function isStepJson(value: unknown): value is StepJson {
  if (!value || typeof value !== "object") {
    return false;
  }

  const obj = value as { [key: string]: unknown };

  if (typeof obj.id !== "string" || !obj.id.trim()) {
    return false;
  }

  if (typeof obj.description !== "string" || !obj.description.trim()) {
    return false;
  }

  if (typeof obj.status !== "string") {
    return false;
  }

  const allowedStatuses: StepStatus[] = ["ğŸ”´ å¾…å®Œæˆ", "ğŸŸ¡ è¿›è¡Œä¸­", "ğŸŸ¢ å·²å®Œæˆ"];
  if (!allowedStatuses.includes(obj.status as StepStatus)) {
    return false;
  }

  if (!Array.isArray(obj.verification)) {
    return false;
  }

  for (const [index, item] of obj.verification.entries()) {
    if (!item || typeof item !== "object") {
      return false;
    }
    const v = item as { type?: unknown; description?: unknown };
    if (typeof v.type !== "string" || !v.type.trim()) {
      return false;
    }
    if (typeof v.description !== "string" || !v.description.trim()) {
      return false;
    }
    // If any verification entry is invalid, consider structure invalid
    if (v.type.trim().length === 0 || v.description.trim().length === 0) {
      throw new Error(`verification[${index}] has empty type or description`);
    }
  }

  return true;
}

function truncateDescription(description: string, maxLength = 120): string {
  const trimmed = description.trim();
  if (trimmed.length <= maxLength) {
    return trimmed;
  }
  return `${trimmed.slice(0, maxLength - 1)}â€¦`;
}

function formatDateTime(dt: Date): string {
  const year = dt.getFullYear();
  const month = String(dt.getMonth() + 1).padStart(2, "0");
  const day = String(dt.getDate()).padStart(2, "0");
  const hour = String(dt.getHours()).padStart(2, "0");
  const minute = String(dt.getMinutes()).padStart(2, "0");
  const second = String(dt.getSeconds()).padStart(2, "0");
  return `${year}-${month}-${day} ${hour}:${minute}:${second}`;
}

function buildRunStepPrompt(params: {
  projectRoot: string;
  stepsDir: string;
  step: StepJson;
  fileName: string;
  order: number;
  total: number;
}): string {
  const { projectRoot, stepsDir, step, fileName, order, total } = params;

  const verificationLines =
    step.verification.length > 0
      ? step.verification
          .map(
            (v, index) =>
              `${index + 1}. [${v.type}] ${v.description}`,
          )
          .join("\n")
      : "ï¼ˆå½“å‰æ­¥éª¤æ²¡æœ‰æ˜¾å¼çš„ verification æ¡ç›®ï¼Œä½†ä½ ä»éœ€è¦æ ¹æ®æè¿°ç¼–å†™åˆç†çš„æµ‹è¯•æˆ–éªŒè¯æ–¹å¼ã€‚ï¼‰";

  return `ä½ æ˜¯ agent-foreman å·¥ç¨‹ä¸­çš„ä¸‹æ¸¸ AI å·¥å…·ï¼Œè´Ÿè´£åœ¨æœ¬åœ°ä»£ç ä»“åº“ä¸­å®ç°å…·ä½“çš„å¼€å‘æ­¥éª¤ã€‚

å½“å‰é¡¹ç›®æ ¹ç›®å½•ï¼ˆå·¥ä½œç›®å½•ï¼‰ä¸ºï¼š
${projectRoot}

æ­¥éª¤æ–‡ä»¶æ‰€åœ¨ç›®å½•ä¸ºï¼š
${stepsDir}

æœ¬æ¬¡è¦æ‰§è¡Œçš„æ­¥éª¤ä¿¡æ¯å¦‚ä¸‹ï¼š
- é¡ºåºï¼šç¬¬ ${order} æ­¥ / å…± ${total} æ­¥
- æ­¥éª¤æ–‡ä»¶ï¼š${fileName}
- æ­¥éª¤ IDï¼š${step.id}
- æè¿°ï¼ˆdescriptionï¼‰ï¼š
${step.description}

éªŒè¯é¡¹ç›®ï¼ˆverificationï¼‰åˆ—è¡¨å¦‚ä¸‹ï¼Œè¯·åŠ¡å¿…å…¨éƒ¨è¦†ç›–ï¼š
${verificationLines}

ä½ çš„ä»»åŠ¡ï¼š
1. åœ¨é¡¹ç›®ä»£ç ä»“åº“ä¸­ï¼Œæ ¹æ®ä¸Šè¿°æ­¥éª¤æè¿°å®Œæˆå¯¹åº”çš„å®ç°å·¥ä½œï¼ˆåŒ…æ‹¬ä»£ç ä¿®æ”¹ã€é…ç½®è°ƒæ•´ã€æ–‡æ¡£æ›´æ–°ç­‰ï¼‰ã€‚
2. é’ˆå¯¹æ¯ä¸€ä¸ª verification æ¡ç›®ï¼Œç¼–å†™å¹¶è¿è¡Œç›¸åº”çš„è‡ªåŠ¨åŒ–æµ‹è¯•æˆ–éªŒè¯æ­¥éª¤ï¼š
   - type ä¸º "unit" æ—¶ï¼šç¼–å†™æˆ–æ›´æ–°å•å…ƒæµ‹è¯•å¹¶è¿è¡Œï¼›
   - type ä¸º "integration" æ—¶ï¼šç¼–å†™æˆ–æ›´æ–°é›†æˆæµ‹è¯•å¹¶è¿è¡Œï¼›
   - type ä¸º "ui" æ—¶ï¼šç¼–å†™æˆ–æ›´æ–° UI è‡ªåŠ¨åŒ–æµ‹è¯•å¹¶è¿è¡Œï¼›
   - type ä¸º "manual" æˆ–å…¶ä»–ç±»å‹æ—¶ï¼šç»™å‡ºæ¸…æ™°çš„äººå·¥éªŒè¯è¯´æ˜ï¼Œå¿…è¦æ—¶ä¹Ÿå¯ä»¥è¡¥å……è‡ªåŠ¨åŒ–æµ‹è¯•ã€‚
3. å……åˆ†åˆ©ç”¨ä½ åœ¨æœ¬åœ°å¯ç”¨çš„å‘½ä»¤ï¼ˆä¾‹å¦‚ npmã€pnpmã€yarnã€pytestã€go test ç­‰ï¼‰è¿è¡Œæµ‹è¯•ï¼Œç¡®ä¿ç›¸å…³æµ‹è¯•å…¨éƒ¨é€šè¿‡ã€‚
4. éµå¾ªæœ¬ä»“åº“å·²æœ‰çš„ä»£ç é£æ ¼å’Œé¡¹ç›®ç»“æ„ï¼Œå°½é‡ä¿æŒæ”¹åŠ¨æœ€å°ä¸”èšç„¦å½“å‰æ­¥éª¤ã€‚
5. åœ¨å®Œæˆå®ç°å’Œå•å…ƒæµ‹è¯•ç¼–å†™åï¼Œè¯·æ ¹æ®ä½ å®é™…ä½¿ç”¨çš„æµ‹è¯•å‘½ä»¤ï¼Œåœ¨è¾“å‡ºæœ«å°¾é™„åŠ ä¸€ä¸ªä»…åŒ…å« \`unit_test\` å­—æ®µçš„ JSON å¯¹è±¡ï¼Œç”¨äºè®°å½•å¦‚ä½•é‡æ–°è¿è¡Œä¸æœ¬æ­¥éª¤ç›¸å…³çš„å•å…ƒæµ‹è¯•ã€‚æ ¼å¼ç¤ºä¾‹ï¼š

{
  "unit_test": {
    "command": "npm test -- tests/run-command.test.ts",
    "files": ["tests/run-command.test.ts"],
    "notes": "è¦†ç›– runStepsDirectory çš„ä¸»è¦åœºæ™¯"
  }
}

è¦æ±‚ï¼š
- åªè¾“å‡ºä¸Šè¿° JSON å¯¹è±¡ï¼Œä¸è¦ä½¿ç”¨ Markdown ä»£ç å—ï¼›
- JSON ä¸­å¿…é¡»ä½¿ç”¨è‹±æ–‡åŒå¼•å·ï¼›
- å¦‚æœä½ è®¤ä¸ºæœ¬æ­¥éª¤ä¸éœ€è¦æˆ–æ— æ³•ç¼–å†™ä¸“é—¨çš„å•å…ƒæµ‹è¯•ï¼Œå¯ä»¥çœç•¥ \`unit_test\` å­—æ®µï¼ˆä¸è¦è¾“å‡ºç©ºå­—æ®µï¼‰ã€‚

é€€å‡ºçº¦å®šï¼š
- å½“ä¸”ä»…å½“ä½ è®¤ä¸ºå½“å‰æ­¥éª¤å·²ç»å®Œå…¨å®ç°ï¼Œä¸”æ‰€æœ‰ç›¸å…³æµ‹è¯•å‡é€šè¿‡æ—¶ï¼Œæ‰ä»¥é€€å‡ºç  0 æ­£å¸¸ç»“æŸï¼›
- å¦‚æœä½ æ— æ³•å®Œæˆå½“å‰æ­¥éª¤ã€é‡åˆ°æ— æ³•è§£å†³çš„é”™è¯¯ã€æˆ–æœ‰ä»»ä½•æµ‹è¯•å¤±è´¥ï¼Œè¯·ä»¥é 0 é€€å‡ºç ç»“æŸï¼Œå¹¶åœ¨è¾“å‡ºä¸­ç®€è¦è¯´æ˜åŸå› ã€‚

è¯·ç°åœ¨å¼€å§‹æ‰§è¡Œè¯¥æ­¥éª¤ã€‚`;
}

function buildRunStepValidationPrompt(params: {
  projectRoot: string;
  stepsDir: string;
  step: StepJson;
  fileName: string;
  order: number;
  total: number;
}): string {
  const { projectRoot, stepsDir, step, fileName, order, total } = params;

  const verificationLines =
    step.verification.length > 0
      ? step.verification
          .map(
            (v, index) =>
              `${index + 1}. [${v.type}] ${v.description}`,
          )
          .join("\n")
      : "ï¼ˆå½“å‰æ­¥éª¤æ²¡æœ‰æ˜¾å¼çš„ verification æ¡ç›®ï¼Œä½†ä½ ä»éœ€è¦æ ¹æ®æè¿°é€‰æ‹©åˆç†çš„æµ‹è¯•æˆ–éªŒè¯æ–¹å¼ã€‚ï¼‰";

  return `ä½ æ˜¯ agent-foreman å·¥ç¨‹ä¸­çš„æµ‹è¯•éªŒè¯åŠ©æ‰‹ï¼Œè´Ÿè´£åœ¨æœ¬åœ°ä»£ç ä»“åº“ä¸­æ ¹æ®æ­¥éª¤æè¿°å’Œ verification åˆ—è¡¨é‡æ–°è¿è¡Œæµ‹è¯•ï¼Œè¿›è¡Œå›å½’éªŒè¯ã€‚

å½“å‰é¡¹ç›®æ ¹ç›®å½•ï¼ˆå·¥ä½œç›®å½•ï¼‰ä¸ºï¼š
${projectRoot}

æ­¥éª¤æ–‡ä»¶æ‰€åœ¨ç›®å½•ä¸ºï¼š
${stepsDir}

æœ¬æ¬¡è¦éªŒè¯çš„æ­¥éª¤ä¿¡æ¯å¦‚ä¸‹ï¼š
- é¡ºåºï¼šç¬¬ ${order} æ­¥ / å…± ${total} æ­¥
- æ­¥éª¤æ–‡ä»¶ï¼š${fileName}
- æ­¥éª¤ IDï¼š${step.id}
- å½“å‰æ­¥éª¤åœ¨ JSON ä¸­çš„çŠ¶æ€ï¼š${step.status}
- æè¿°ï¼ˆdescriptionï¼‰ï¼š
${step.description}

éªŒè¯é¡¹ç›®ï¼ˆverificationï¼‰åˆ—è¡¨å¦‚ä¸‹ï¼Œè¯·åŠ¡å¿…å…¨éƒ¨è¦†ç›–ï¼š
${verificationLines}

ä½ çš„ä»»åŠ¡ï¼ˆä»…é™æµ‹è¯•éªŒè¯ï¼Œä¸å…è®¸ä¿®æ”¹ä»»ä½•ä»£ç æˆ–é…ç½®ï¼‰ï¼š
1. åªæ ¹æ®ä¸Šè¿°æè¿°å’Œ verification æ¡ç›®ï¼Œé€‰æ‹©å¹¶æ‰§è¡Œåˆé€‚çš„æµ‹è¯•å‘½ä»¤ï¼ˆä¾‹å¦‚ npm test / pnpm test / è‡ªå®šä¹‰è„šæœ¬ç­‰ï¼‰ï¼ŒéªŒè¯è¯¥æ­¥éª¤å¯¹åº”çš„åŠŸèƒ½æ˜¯å¦ä»ç„¶æ­£ç¡®ã€‚
2. ä½ å¯ä»¥é˜…è¯»ä»£ç å’Œæµ‹è¯•æ–‡ä»¶ï¼Œä½†ç¦æ­¢ä¿®æ”¹ä»»ä½•æºä»£ç ã€é…ç½®æ–‡ä»¶ã€æµ‹è¯•æ–‡ä»¶æˆ–æ–‡æ¡£å†…å®¹â€”â€”æœ¬è½®ä»…åšã€Œå›å½’éªŒè¯ã€ï¼Œä¸åšå®ç°æ”¹åŠ¨ã€‚
3. å¦‚æœä½ è®¤ä¸ºæ‰€æœ‰ä¸æœ¬æ­¥éª¤ç›¸å…³çš„æµ‹è¯•å‡å·²è¦†ç›–ä¸”å…¨éƒ¨é€šè¿‡ï¼Œåˆ™ä»¥é€€å‡ºç  0 æ­£å¸¸ç»“æŸã€‚
4. å¦‚æœæœ‰ä»»æ„æµ‹è¯•å¤±è´¥ã€å‘ç°æ˜æ˜¾ç¼ºé™·ã€æˆ–ä½ æ— æ³•ç¡®è®¤è¯¥æ­¥éª¤å·²ç»å®Œå…¨æ»¡è¶³æè¿°å’Œ verification è¦æ±‚ï¼Œè¯·ä»¥é 0 é€€å‡ºç ç»“æŸï¼Œå¹¶åœ¨è¾“å‡ºä¸­ç®€è¦è¯´æ˜å¤±è´¥åŸå› æˆ–é£é™©ç‚¹ã€‚

é€€å‡ºçº¦å®šï¼š
- é€€å‡ºç  0ï¼šè¡¨ç¤ºæœ¬æ¬¡å›å½’éªŒè¯é€šè¿‡ï¼Œå½“å‰æ­¥éª¤å¯ä»¥ç»§ç»­ä¿æŒä¸ºâ€œğŸŸ¢ å·²å®Œæˆâ€çŠ¶æ€ï¼›
- é 0 é€€å‡ºç ï¼šè¡¨ç¤ºæœ¬æ¬¡å›å½’éªŒè¯æœªé€šè¿‡æˆ–å­˜åœ¨ä¸ç¡®å®šæ€§ï¼Œè°ƒç”¨æ–¹ä¼šæ ¹æ®éœ€è¦é‡æ–°æ‰“å¼€æ­¥éª¤å¹¶è¿›å…¥å®ç°é˜¶æ®µã€‚

è¯·ç°åœ¨å¼€å§‹æ‰§è¡Œå›å½’éªŒè¯ï¼Œä»…è¿è¡Œæµ‹è¯•å’Œæ£€æŸ¥ç»“æœï¼Œä¸è¦ä¿®æ”¹ä»»ä½•ä»£ç æˆ–é…ç½®ã€‚`;
}

async function discoverStepFiles(stepsDir: string): Promise<{
  stepFiles: string[];
  otherJsonFiles: string[];
}> {
  const entries = await fs.readdir(stepsDir);
  const jsonFiles = entries.filter((name) => name.toLowerCase().endsWith(".json"));

  if (jsonFiles.length === 0) {
    throw new Error("æ­¥éª¤ç›®å½•ä¸­æœªæ‰¾åˆ°ä»»ä½• JSON æ­¥éª¤æ–‡ä»¶");
  }

  const stepPattern = /^\d{3}-.+\.json$/;
  const stepFiles = jsonFiles.filter((name) => stepPattern.test(name));
  const otherJsonFiles = jsonFiles.filter((name) => !stepPattern.test(name));

  if (stepFiles.length === 0) {
    throw new Error(
      `åœ¨æ­¥éª¤ç›®å½•ä¸­æœªæ‰¾åˆ°ç¬¦åˆ "NNN-*.json" å‘½åè§„åˆ™çš„æ­¥éª¤æ–‡ä»¶ï¼Œæ‰¾åˆ°çš„ JSON æ–‡ä»¶æœ‰ï¼š${jsonFiles.join(
        ", ",
      )}`,
    );
  }

  stepFiles.sort((a, b) => a.localeCompare(b));

  return { stepFiles, otherJsonFiles };
}

async function loadStepEntries(
  stepsDir: string,
  stepFiles: string[],
): Promise<{ entries: RunStepEntry[]; hasParseError: boolean }> {
  const entries: RunStepEntry[] = [];
  let hasParseError = false;

  for (let index = 0; index < stepFiles.length; index++) {
    const fileName = stepFiles[index];
    const filePath = path.join(stepsDir, fileName);
    const prefix = fileName.slice(0, 3);
    const order = index + 1;
    const entry: RunStepEntry = {
      order,
      prefix,
      fileName,
      filePath,
    };

    try {
      const content = await fs.readFile(filePath, "utf-8");
      let parsed: unknown;
      try {
        parsed = JSON.parse(content);
      } catch (err) {
        throw new Error(
          err instanceof Error ? `JSON è§£æå¤±è´¥ï¼š${err.message}` : "JSON è§£æå¤±è´¥",
        );
      }

      if (!isStepJson(parsed)) {
        throw new Error("JSON ç»“æ„ä¸ç¬¦åˆæ­¥éª¤æ–‡ä»¶è¦æ±‚");
      }

      const step = parsed as StepJson;

      entry.id = step.id;
      entry.description = step.description;
      entry.initialStatus = step.status;
      entry.finalStatus = step.status;
      entry.verification = step.verification;
      entry.unitTest = step.unit_test;

      const expectedId = `step-${prefix}`;
      if (step.id !== expectedId) {
        console.log(
          chalk.yellow(
            `âš  æ­¥éª¤æ–‡ä»¶ ${fileName} çš„ id å­—æ®µä¸º "${step.id}"ï¼Œä¸æ–‡ä»¶åå‰ç¼€ "${prefix}" ä¸ä¸€è‡´ï¼ˆé¢„æœŸä¸º "${expectedId}"ï¼‰`,
          ),
        );
      }
    } catch (err) {
      hasParseError = true;
      const message =
        err instanceof Error ? err.message : "æœªçŸ¥é”™è¯¯ï¼Œæ— æ³•è§£ææ­¥éª¤ JSON æ–‡ä»¶";
      entry.parseError = message;
      entry.error = message;
      console.log(
        chalk.red(
          `âœ— æ— æ³•è§£ææ­¥éª¤æ–‡ä»¶ ${fileName}: ${message}`,
        ),
      );
    }

    entries.push(entry);
  }

  return { entries, hasParseError };
}

async function writeProgressMarkdown(params: {
  stepsDir: string;
  entries: RunStepEntry[];
  startedAt: Date;
  finishedAt: Date;
}): Promise<string> {
  const { stepsDir, entries, startedAt, finishedAt } = params;

  const fileName = "run-progress.md";
  const filePath = path.join(stepsDir, fileName);

  const total = entries.length;
  const successCount = entries.filter((e) => e.success).length;
  const failureCount = entries.filter((e) => e.success === false).length;

  const lines: string[] = [];

  lines.push(`# agent-foreman run æ‰§è¡Œè¿›åº¦æŠ¥å‘Š`);
  lines.push("");
  lines.push(`- æ­¥éª¤ç›®å½•: \`${stepsDir}\``);
  lines.push(`- å¼€å§‹æ—¶é—´: ${formatDateTime(startedAt)}`);
  lines.push(`- ç»“æŸæ—¶é—´: ${formatDateTime(finishedAt)}`);
  lines.push(`- æ€»æ­¥éª¤æ•°: ${total}`);
  lines.push(`- æˆåŠŸæ­¥éª¤æ•°: ${successCount}`);
  lines.push(`- å¤±è´¥æ­¥éª¤æ•°: ${failureCount}`);
  lines.push("");

  lines.push("## æ­¥éª¤æ˜ç»†");
  lines.push("");
  lines.push("| é¡ºåº | æ–‡ä»¶å | æ­¥éª¤ ID | æ‰§è¡Œå‰çŠ¶æ€ | æ‰§è¡ŒåçŠ¶æ€ | ç»“æœ | æ‘˜è¦ | é”™è¯¯ä¿¡æ¯ |");
  lines.push("| ---- | ------ | ------- | ---------- | ---------- | ---- | ---- | -------- |");

  for (const entry of entries) {
    const before = entry.initialStatus ?? "";
    const after = entry.finalStatus ?? before;
    const result =
      entry.success === true
        ? "æˆåŠŸ"
        : entry.success === false
          ? "å¤±è´¥"
          : "æœªæ‰§è¡Œ";
    const summary = entry.description
      ? truncateDescription(entry.description, 60).replace(/\|/g, "\\|")
      : "";
    const error = entry.error
      ? truncateDescription(entry.error, 80).replace(/\|/g, "\\|")
      : "";

    lines.push(
      `| ${entry.order
        .toString()
        .padStart(3, " ")} | ${entry.fileName} | ${entry.id ?? ""} | ${before} | ${after} | ${result} | ${summary} | ${error} |`,
    );
  }

  const content = `${lines.join("\n")}\n`;
  await fs.writeFile(filePath, content, "utf-8");

  return filePath;
}

function extractUnitTestFromOutput(output: string): StepUnitTest | undefined {
  const jsonStr = extractJsonObject(output);
  if (!jsonStr) return undefined;

  let parsed: unknown;
  try {
    parsed = JSON.parse(jsonStr);
  } catch {
    return undefined;
  }

  if (!parsed || typeof parsed !== "object") return undefined;

  const obj = parsed as { unit_test?: unknown };
  const rawUnit = obj.unit_test;
  if (!rawUnit || typeof rawUnit !== "object") return undefined;

  const u = rawUnit as { command?: unknown; files?: unknown; notes?: unknown };

  if (typeof u.command !== "string" || !u.command.trim()) return undefined;
  const command = u.command.trim();

  let files: string[] | undefined;
  if (Array.isArray(u.files)) {
    files = u.files.filter((f): f is string => typeof f === "string" && f.trim().length > 0);
  }

  const notes = typeof u.notes === "string" && u.notes.trim().length > 0 ? u.notes.trim() : undefined;

  return { command, files, notes };
}

async function runUnitTestsForStep(
  unitTest: StepUnitTest,
  cwd: string,
): Promise<{ success: boolean; error?: string; output?: string }> {
  const result = spawnSync(unitTest.command, {
    cwd,
    shell: true,
    encoding: "utf-8",
  });

  const stdout = (result.stdout || "").toString();
  const stderr = (result.stderr || "").toString();
  const combined = `${stdout}${stdout && stderr ? "\n" : ""}${stderr}`;

  if (result.status === 0) {
    return { success: true, output: combined };
  }

  const message =
    combined.trim() || `Unit test command exited with code ${result.status ?? "unknown"}`;

  return {
    success: false,
    error: message,
    output: combined,
  };
}

export async function runStepsDirectory(
  stepsDirArg: string,
  options: { fullVerify?: boolean } = {},
): Promise<void> {
  const cwd = process.cwd();
  const stepsDir = path.isAbsolute(stepsDirArg)
    ? stepsDirArg
    : path.join(cwd, stepsDirArg);

  const startedAt = new Date();

  let stat;
  try {
    stat = await fs.stat(stepsDir);
  } catch {
    console.log(chalk.red(`âœ— æ­¥éª¤ç›®å½•ä¸å­˜åœ¨ï¼š${stepsDirArg}`));
    process.exitCode = 1;
    return;
  }

  if (!stat.isDirectory()) {
    console.log(chalk.red(`âœ— æä¾›çš„è·¯å¾„ä¸æ˜¯ç›®å½•ï¼š${stepsDirArg}`));
    process.exitCode = 1;
    return;
  }

  let stepFiles: string[];
  let otherJsonFiles: string[];

  try {
    const discovered = await discoverStepFiles(stepsDir);
    stepFiles = discovered.stepFiles;
    otherJsonFiles = discovered.otherJsonFiles;
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "æ— æ³•å‘ç°æ­¥éª¤ JSON æ–‡ä»¶";
    console.log(chalk.red(`âœ— ${message}`));
    process.exitCode = 1;
    return;
  }

  if (otherJsonFiles.length > 0) {
    console.log(
      chalk.yellow(
        `âš  å‘ç° ${otherJsonFiles.length} ä¸ªå‘½åä¸ç¬¦åˆ "NNN-*.json" è§„åˆ™çš„ JSON æ–‡ä»¶ï¼Œå®ƒä»¬ä¸ä¼šä½œä¸ºæ­¥éª¤æ‰§è¡Œï¼š${otherJsonFiles.join(
          ", ",
        )}`,
      ),
    );
  }

  console.log(
    chalk.blue(
      `ğŸ§© å³å°†æ‰§è¡Œ ${stepFiles.length} ä¸ªæ­¥éª¤ï¼ˆç›®å½•ï¼š${stepsDirArg}ï¼‰`,
    ),
  );
  console.log(
    chalk.gray(
      `  æ‰§è¡Œé¡ºåºï¼ˆå‰å‡ é¡¹é¢„è§ˆï¼‰ï¼š${stepFiles
        .slice(0, 5)
        .join(", ")}${stepFiles.length > 5 ? " ..." : ""}`,
    ),
  );

  const { entries, hasParseError } = await loadStepEntries(stepsDir, stepFiles);

  if (hasParseError) {
    console.log(
      chalk.red(
        "âœ— æœ‰æ­¥éª¤ JSON æ–‡ä»¶ç»“æ„ä¸åˆæ³•ï¼Œå·²ä¸­æ­¢æ‰§è¡Œã€‚è¯·ä¿®æ­£ä¸Šè¿°é”™è¯¯åé‡è¯•ã€‚",
      ),
    );
    const finishedAt = new Date();
    const progressPath = await writeProgressMarkdown({
      stepsDir,
      entries,
      startedAt,
      finishedAt,
    });
    console.log(chalk.gray(`  æ‰§è¡Œè¿›åº¦æŠ¥å‘Šå·²å†™å…¥ï¼š${progressPath}`));
    process.exitCode = 1;
    return;
  }

  const total = entries.length;
  let firstFailure: RunStepEntry | undefined;

  for (const entry of entries) {
    if (!entry.id || !entry.description || !entry.verification) {
      // Should not happen if loadStepEntries passed validation, but keep safe
      entry.success = false;
      entry.error = "æ­¥éª¤å…ƒæ•°æ®ä¸å®Œæ•´ï¼Œæ— æ³•æ‰§è¡Œ";
      firstFailure = firstFailure ?? entry;
      break;
    }

    const step: StepJson = {
      id: entry.id,
      description: entry.description,
      status: entry.initialStatus ?? "ğŸ”´ å¾…å®Œæˆ",
      verification: entry.verification,
    };

    console.log("");
    console.log(
      chalk.bold(
        `[${entry.order}/${total}] ${entry.fileName} (${step.id})`,
      ),
    );
    console.log(
      chalk.gray(
        `  æè¿°: ${truncateDescription(step.description)}`,
      ),
    );
    console.log(
      chalk.gray(
        `  å½“å‰çŠ¶æ€: ${step.status}`,
      ),
    );

    let needImplementation = step.status !== "ğŸŸ¢ å·²å®Œæˆ";

    // å¦‚æœå½“å‰ä¸ºå·²å®ŒæˆçŠ¶æ€ï¼Œä¸”å¼€å¯äº† fullVerifyï¼Œåˆ™å…ˆè¿›è¡Œä¸€æ¬¡ã€Œä»…æµ‹è¯•ã€çš„å›å½’éªŒè¯
    if (step.status === "ğŸŸ¢ å·²å®Œæˆ" && options.fullVerify) {
      console.log(
        chalk.gray(
          "  å½“å‰æ­¥éª¤å·²æ ‡è®°ä¸ºå·²å®Œæˆï¼Œå°†ä»…é‡æ–°è¿è¡Œæµ‹è¯•è¿›è¡Œå›å½’éªŒè¯...",
        ),
      );

      // å¦‚æœæ­¥éª¤åŒ…å« unit_test ä¿¡æ¯ï¼Œå…ˆæŒ‰å…¶å†…å®¹è¿è¡Œå•å…ƒæµ‹è¯•
      if (entry.unitTest && entry.unitTest.command) {
        console.log(
          chalk.gray(
            `  ğŸ§ª æ‰§è¡Œå•å…ƒæµ‹è¯•: ${entry.unitTest.command}`,
          ),
        );
        const testResult = await runUnitTestsForStep(entry.unitTest, cwd);
        if (testResult.success) {
          console.log(chalk.green("  âœ“ å•å…ƒæµ‹è¯•é€šè¿‡"));
        } else {
          console.log(chalk.red("  âœ— å•å…ƒæµ‹è¯•å¤±è´¥"));
          if (testResult.error) {
            testResult.error
              .split("\n")
              .slice(0, 10)
              .forEach((line) => {
                if (line.trim()) {
                  console.log(chalk.red(`    ${line}`));
                }
              });
          }

          entry.finalStatus = step.status;
          entry.success = false;
          entry.error = "å•å…ƒæµ‹è¯•å¤±è´¥";

          const now = new Date();
          await writeProgressMarkdown({
            stepsDir,
            entries,
            startedAt,
            finishedAt: now,
          });

          console.log(
            chalk.yellow(
              "  âš  å•å…ƒæµ‹è¯•æœªé€šè¿‡ï¼Œå°†é‡æ–°æ‰“å¼€è¯¥æ­¥éª¤å¹¶è¿›å…¥å®ç°é˜¶æ®µ...",
            ),
          );
          needImplementation = true;
        }
      }

      // å¦‚æœå•å…ƒæµ‹è¯•é€šè¿‡ï¼ˆæˆ–ä¸å­˜åœ¨ï¼‰ï¼Œå†è°ƒç”¨ AI æŒ‰ verification åšå›å½’éªŒè¯
      if (!needImplementation) {
        const validationPrompt = buildRunStepValidationPrompt({
          projectRoot: cwd,
          stepsDir,
          step,
          fileName: entry.fileName,
          order: entry.order,
          total,
        });

        console.log(chalk.gray("  æ­£åœ¨è°ƒç”¨å‘½ä»¤è¡Œ AI è¿›è¡Œå›å½’æµ‹è¯•éªŒè¯..."));

        const validationResult = await callAnyAvailableAgent(validationPrompt, {
          cwd,
          verbose: true,
        });

        if (validationResult.success) {
          // å›å½’æµ‹è¯•é€šè¿‡ï¼Œä¿æŒçŠ¶æ€ä¸ºå·²å®Œæˆï¼Œä¸è¿›å…¥å®ç°é˜¶æ®µ
          entry.finalStatus = step.status;
          entry.success = true;
          entry.error = undefined;
          console.log(
            chalk.green(
              "  âœ“ å›å½’æµ‹è¯•é€šè¿‡ï¼Œä¿æŒçŠ¶æ€ä¸ºï¼šğŸŸ¢ å·²å®Œæˆ",
            ),
          );

          // æ›´æ–°è¿›åº¦æŠ¥å‘Š
          const now = new Date();
          await writeProgressMarkdown({
            stepsDir,
            entries,
            startedAt,
            finishedAt: now,
          });
          continue;
        }

        console.log(
          chalk.yellow(
            `  âš  å›å½’æµ‹è¯•æœªé€šè¿‡æˆ–å­˜åœ¨é—®é¢˜ï¼ˆ${validationResult.error ?? "åŸå› æœªçŸ¥"}ï¼‰ï¼Œå°†é‡æ–°æ‰“å¼€è¯¥æ­¥éª¤å¹¶è¿›å…¥å®ç°é˜¶æ®µ...`,
          ),
        );
        needImplementation = true;
      }
    }

    if (!needImplementation) {
      continue;
    }

    // æ ‡è®°ä¸ºè¿›è¡Œä¸­
    const previousStatus = step.status;
    step.status = "ğŸŸ¡ è¿›è¡Œä¸­";
    entry.finalStatus = step.status;

    try {
      await fs.writeFile(
        entry.filePath,
        JSON.stringify(step, null, 2),
        "utf-8",
      );
    } catch (err) {
      const message =
        err instanceof Error ? err.message : "æ— æ³•å†™å…¥æ­¥éª¤ JSON æ–‡ä»¶";
      console.log(
        chalk.red(
          `âœ— æ— æ³•æ›´æ–°æ­¥éª¤æ–‡ä»¶ ${entry.fileName}: ${message}`,
        ),
      );
      entry.success = false;
      entry.error = message;
      firstFailure = firstFailure ?? entry;

      const now = new Date();
      await writeProgressMarkdown({
        stepsDir,
        entries,
        startedAt,
        finishedAt: now,
      });
      break;
    }

    console.log(
      chalk.gray(
        `  çŠ¶æ€æ›´æ–°: ${previousStatus} â†’ ${step.status}`,
      ),
    );

    const prompt = buildRunStepPrompt({
      projectRoot: cwd,
      stepsDir,
      step,
      fileName: entry.fileName,
      order: entry.order,
      total,
    });

    console.log(chalk.gray("  æ­£åœ¨è°ƒç”¨å‘½ä»¤è¡Œ AI å¤„ç†è¯¥æ­¥éª¤..."));

    const result = await callAnyAvailableAgent(prompt, {
      cwd,
      verbose: true,
    });

    if (result.success) {
      step.status = "ğŸŸ¢ å·²å®Œæˆ";
      entry.finalStatus = step.status;
      entry.success = true;
      entry.error = undefined;

      const unitTest = extractUnitTestFromOutput(result.output);
      if (unitTest) {
        step.unit_test = unitTest;
        entry.unitTest = unitTest;
        console.log(
          chalk.gray(
            `  å•å…ƒæµ‹è¯•ä¿¡æ¯å·²è®°å½•åˆ°æ­¥éª¤ JSONï¼ˆå‘½ä»¤ï¼š${unitTest.command}ï¼‰`,
          ),
        );
      }

      try {
        await fs.writeFile(
          entry.filePath,
          JSON.stringify(step, null, 2),
          "utf-8",
        );
      } catch (err) {
        const message =
          err instanceof Error ? err.message : "æ— æ³•å†™å…¥æ­¥éª¤ JSON æ–‡ä»¶";
        console.log(
          chalk.red(
            `âœ— æ­¥éª¤å·²æˆåŠŸæ‰§è¡Œï¼Œä½†å†™å›çŠ¶æ€åˆ°æ–‡ä»¶æ—¶å¤±è´¥ï¼š${message}`,
          ),
        );
        entry.success = false;
        entry.error = message;
        firstFailure = firstFailure ?? entry;
        break;
      }

      console.log(
        chalk.green(
          `  âœ“ æ­¥éª¤æ‰§è¡ŒæˆåŠŸï¼ŒçŠ¶æ€å·²æ›´æ–°ä¸ºï¼š${step.status}`,
        ),
      );

      // æ™®é€š run æ¨¡å¼ä¸‹ï¼Œæ‰§è¡Œã€Œå•å…ƒæµ‹è¯• + verification éªŒè¯ã€
      if (!options.fullVerify) {
        // å…ˆæ‰§è¡Œå•å…ƒæµ‹è¯•ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        if (entry.unitTest && entry.unitTest.command) {
          console.log(
            chalk.gray(
              `  ğŸ§ª æ‰§è¡Œå•å…ƒæµ‹è¯•: ${entry.unitTest.command}`,
            ),
          );
          const testResult = await runUnitTestsForStep(entry.unitTest, cwd);
          if (!testResult.success) {
            console.log(chalk.red("  âœ— å•å…ƒæµ‹è¯•å¤±è´¥"));
            if (testResult.error) {
              testResult.error
                .split("\n")
                .slice(0, 10)
                .forEach((line) => {
                  if (line.trim()) {
                    console.log(chalk.red(`    ${line}`));
                  }
                });
            }

            step.status = "ğŸ”´ å¾…å®Œæˆ";
            entry.finalStatus = step.status;
            entry.success = false;
            entry.error = "å•å…ƒæµ‹è¯•å¤±è´¥";

            try {
              await fs.writeFile(
                entry.filePath,
                JSON.stringify(step, null, 2),
                "utf-8",
              );
            } catch {
              // å¦‚æœè¿™é‡Œå†™å›å¤±è´¥ï¼Œé”™è¯¯å·²ç»åœ¨å‰é¢å¤„ç†è¿‡ï¼Œè¿™é‡Œä¸å†é¢å¤–ä¸­æ–­
            }

            const now = new Date();
            await writeProgressMarkdown({
              stepsDir,
              entries,
              startedAt,
              finishedAt: now,
            });

            firstFailure = firstFailure ?? entry;
            break;
          } else {
            console.log(chalk.green("  âœ“ å•å…ƒæµ‹è¯•é€šè¿‡"));
          }
        }

        // å†æŒ‰ verification åˆ—è¡¨è®© AI åšä¸€æ¬¡éªŒè¯
        const validationPrompt = buildRunStepValidationPrompt({
          projectRoot: cwd,
          stepsDir,
          step,
          fileName: entry.fileName,
          order: entry.order,
          total,
        });

        console.log(chalk.gray("  æ­£åœ¨è°ƒç”¨å‘½ä»¤è¡Œ AI æŒ‰ verification è¿›è¡ŒéªŒè¯..."));

        const validationResult = await callAnyAvailableAgent(validationPrompt, {
          cwd,
          verbose: true,
        });

        if (!validationResult.success) {
          console.log(
            chalk.red(
              `  âœ— verification éªŒè¯æœªé€šè¿‡ï¼š${validationResult.error ?? "åŸå› æœªçŸ¥"}`,
            ),
          );

          step.status = "ğŸ”´ å¾…å®Œæˆ";
          entry.finalStatus = step.status;
          entry.success = false;
          entry.error = validationResult.error || "verification éªŒè¯å¤±è´¥";

          try {
            await fs.writeFile(
              entry.filePath,
              JSON.stringify(step, null, 2),
              "utf-8",
            );
          } catch {
            // åŒä¸Šï¼Œå†™å›å¤±è´¥ä¸å†é¢å¤–ä¸­æ–­
          }

          const now = new Date();
          await writeProgressMarkdown({
            stepsDir,
            entries,
            startedAt,
            finishedAt: now,
          });

          firstFailure = firstFailure ?? entry;
          break;
        } else {
          console.log(chalk.green("  âœ“ verification éªŒè¯é€šè¿‡"));
        }
      }

      const now = new Date();
      await writeProgressMarkdown({
        stepsDir,
        entries,
        startedAt,
        finishedAt: now,
      });
    } else {
      step.status = "ğŸ”´ å¾…å®Œæˆ";
      entry.finalStatus = step.status;
      entry.success = false;
      entry.error = result.error || "AI å­è¿›ç¨‹æ‰§è¡Œå¤±è´¥";

      try {
        await fs.writeFile(
          entry.filePath,
          JSON.stringify(step, null, 2),
          "utf-8",
        );
      } catch (err) {
        const message =
          err instanceof Error ? err.message : "æ— æ³•å†™å…¥æ­¥éª¤ JSON æ–‡ä»¶";
        console.log(
          chalk.red(
            `âœ— æ— æ³•å†™å›å¤±è´¥çŠ¶æ€åˆ°æ­¥éª¤æ–‡ä»¶ï¼š${message}`,
          ),
        );
      }

      console.log(
        chalk.red(
          `âœ— æ­¥éª¤æ‰§è¡Œå¤±è´¥ï¼š${entry.error}`,
        ),
      );
      firstFailure = firstFailure ?? entry;

      const now = new Date();
      await writeProgressMarkdown({
        stepsDir,
        entries,
        startedAt,
        finishedAt: now,
      });
      break;
    }
  }

  const successCount = entries.filter((e) => e.success).length;
  const totalSteps = entries.length;

  console.log("");
  console.log(
    chalk.bold(
      `ğŸ“‹ æœ¬æ¬¡ run æ‰§è¡Œç»“æœï¼š${successCount}/${totalSteps} ä¸ªæ­¥éª¤æ‰§è¡ŒæˆåŠŸ`,
    ),
  );

  if (firstFailure) {
    console.log(
      chalk.red(
        `âœ— ç¬¬ä¸€ä¸ªå¤±è´¥çš„æ­¥éª¤ï¼š${firstFailure.fileName}${
          firstFailure.id ? ` (${firstFailure.id})` : ""
        }`,
      ),
    );
    if (firstFailure.error) {
      console.log(chalk.red(`  é”™è¯¯åŸå› ï¼š${firstFailure.error}`));
    }
    process.exitCode = 1;
  } else {
    console.log(chalk.green("âœ“ æ‰€æœ‰æ­¥éª¤å‡å·²æˆåŠŸæ‰§è¡Œ"));
  }

  const finishedAt = new Date();
  const progressPath = await writeProgressMarkdown({
    stepsDir,
    entries,
    startedAt,
    finishedAt,
  });
  console.log(chalk.gray(`  æ‰§è¡Œè¿›åº¦æŠ¥å‘Šå·²å†™å…¥ï¼š${progressPath}`));
}
