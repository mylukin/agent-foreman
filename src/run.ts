/**
 * Implementation of `run` command
 * Executes JSON step files generated by `analyze` command
 */
import * as fs from "node:fs/promises";
import * as path from "node:path";
import { spawnSync } from "node:child_process";
import chalk from "chalk";
import { callAnyAvailableAgent } from "./agents.js";
import { extractJsonObject, type VerificationItem } from "./analyze.js";

export type StepStatus = "ğŸ”´ å¾…å®Œæˆ" | "ğŸŸ¡ è¿›è¡Œä¸­" | "ğŸŸ¢ å·²å®Œæˆ";

export interface StepUnitTest {
  command: string;
  files?: string[];
  notes?: string;
}

export interface StepJson {
  id: string;
  description: string;
  status: StepStatus;
  verification: VerificationItem[];
  unit_test?: StepUnitTest;
  // Allow extra fields for forward compatibility
  [key: string]: unknown;
}

export interface PreviousAttemptFailureContext {
  attempt: number;
  maxAttempts: number;
  fromStatus: StepStatus;
  toStatus: StepStatus;
  unitTestCommand?: string;
  unitTestOutputSnippet?: string;
  verificationError?: string;
  aiError?: string;
}

export interface RunStepsOptions {
  fullVerify?: boolean;
  verifyOnly?: boolean;
  verifyUnitTestOnly?: boolean;
  verifyGenerateUnitTest?: boolean;
}

interface RunStepEntry {
  order: number;
  prefix: string;
  fileName: string;
  filePath: string;
  id?: string;
  description?: string;
  initialStatus?: StepStatus;
  finalStatus?: StepStatus;
  verification?: VerificationItem[];
  unitTest?: StepUnitTest;
  parseError?: string;
  success?: boolean;
  error?: string;
}

function isStepJson(value: unknown): value is StepJson {
  if (!value || typeof value !== "object") {
    return false;
  }

  const obj = value as { [key: string]: unknown };

  if (typeof obj.id !== "string" || !obj.id.trim()) {
    return false;
  }

  if (typeof obj.description !== "string" || !obj.description.trim()) {
    return false;
  }

  if (typeof obj.status !== "string") {
    return false;
  }

  const allowedStatuses: StepStatus[] = ["ğŸ”´ å¾…å®Œæˆ", "ğŸŸ¡ è¿›è¡Œä¸­", "ğŸŸ¢ å·²å®Œæˆ"];
  if (!allowedStatuses.includes(obj.status as StepStatus)) {
    return false;
  }

  if (!Array.isArray(obj.verification)) {
    return false;
  }

  for (const [index, item] of obj.verification.entries()) {
    if (!item || typeof item !== "object") {
      return false;
    }
    const v = item as { type?: unknown; description?: unknown };
    if (typeof v.type !== "string" || !v.type.trim()) {
      return false;
    }
    if (typeof v.description !== "string" || !v.description.trim()) {
      return false;
    }
    // If any verification entry is invalid, consider structure invalid
    if (v.type.trim().length === 0 || v.description.trim().length === 0) {
      throw new Error(`verification[${index}] has empty type or description`);
    }
  }

  return true;
}

function truncateDescription(description: string, maxLength = 120): string {
  const trimmed = description.trim();
  if (trimmed.length <= maxLength) {
    return trimmed;
  }
  return `${trimmed.slice(0, maxLength - 1)}â€¦`;
}

function formatDateTime(dt: Date): string {
  const year = dt.getFullYear();
  const month = String(dt.getMonth() + 1).padStart(2, "0");
  const day = String(dt.getDate()).padStart(2, "0");
  const hour = String(dt.getHours()).padStart(2, "0");
  const minute = String(dt.getMinutes()).padStart(2, "0");
  const second = String(dt.getSeconds()).padStart(2, "0");
  return `${year}-${month}-${day} ${hour}:${minute}:${second}`;
}

function buildOutputSnippet(
  output: string,
  maxLines = 20,
  maxLength = 2000,
): string {
  const lines = output.split("\n");
  const sliced = lines.slice(0, maxLines);
  let snippet = sliced.join("\n");

  if (snippet.length > maxLength) {
    snippet = `${snippet.slice(0, maxLength - 1)}â€¦`;
  }

  if (lines.length > maxLines) {
    snippet = `${snippet}\n... (output truncated)`;
  }

  return snippet.trim();
}

function buildRunStepPrompt(params: {
  projectRoot: string;
  stepsDir: string;
  step: StepJson;
  fileName: string;
  order: number;
  total: number;
}): string {
  const { projectRoot, stepsDir, step, fileName, order, total } = params;

  const verificationLines =
    step.verification.length > 0
      ? step.verification
          .map(
            (v, index) =>
              `${index + 1}. [${v.type}] ${v.description}`,
          )
          .join("\n")
      : "ï¼ˆå½“å‰æ­¥éª¤æ²¡æœ‰æ˜¾å¼çš„ verification æ¡ç›®ï¼Œä½†ä½ ä»éœ€è¦æ ¹æ®æè¿°ç¼–å†™åˆç†çš„æµ‹è¯•æˆ–éªŒè¯æ–¹å¼ã€‚ï¼‰";

  return `ä½ æ˜¯ agent-foreman å·¥ç¨‹ä¸­çš„ä¸‹æ¸¸ AI å·¥å…·ï¼Œè´Ÿè´£åœ¨æœ¬åœ°ä»£ç ä»“åº“ä¸­å®ç°å…·ä½“çš„å¼€å‘æ­¥éª¤ã€‚

å½“å‰é¡¹ç›®æ ¹ç›®å½•ï¼ˆå·¥ä½œç›®å½•ï¼‰ä¸ºï¼š
${projectRoot}

æ­¥éª¤æ–‡ä»¶æ‰€åœ¨ç›®å½•ä¸ºï¼š
${stepsDir}

æœ¬æ¬¡è¦æ‰§è¡Œçš„æ­¥éª¤ä¿¡æ¯å¦‚ä¸‹ï¼š
- é¡ºåºï¼šç¬¬ ${order} æ­¥ / å…± ${total} æ­¥
- æ­¥éª¤æ–‡ä»¶ï¼š${fileName}
- æ­¥éª¤ IDï¼š${step.id}
- æè¿°ï¼ˆdescriptionï¼‰ï¼š
${step.description}

éªŒè¯é¡¹ç›®ï¼ˆverificationï¼‰åˆ—è¡¨å¦‚ä¸‹ï¼Œè¯·åŠ¡å¿…å…¨éƒ¨è¦†ç›–ï¼š
${verificationLines}

ä½ çš„ä»»åŠ¡ï¼š
1. åœ¨é¡¹ç›®ä»£ç ä»“åº“ä¸­ï¼Œæ ¹æ®ä¸Šè¿°æ­¥éª¤æè¿°å®Œæˆå¯¹åº”çš„å®ç°å·¥ä½œï¼ˆåŒ…æ‹¬ä»£ç ä¿®æ”¹ã€é…ç½®è°ƒæ•´ã€æ–‡æ¡£æ›´æ–°ç­‰ï¼‰ã€‚
2. é’ˆå¯¹æ¯ä¸€ä¸ª verification æ¡ç›®ï¼Œç¼–å†™å¹¶è¿è¡Œç›¸åº”çš„è‡ªåŠ¨åŒ–æµ‹è¯•æˆ–éªŒè¯æ­¥éª¤ï¼š
   - type ä¸º "unit" æ—¶ï¼šç¼–å†™æˆ–æ›´æ–°å•å…ƒæµ‹è¯•å¹¶è¿è¡Œï¼›
   - type ä¸º "integration" æ—¶ï¼šç¼–å†™æˆ–æ›´æ–°é›†æˆæµ‹è¯•å¹¶è¿è¡Œï¼›
   - type ä¸º "ui" æ—¶ï¼šç¼–å†™æˆ–æ›´æ–° UI è‡ªåŠ¨åŒ–æµ‹è¯•å¹¶è¿è¡Œï¼›
   - type ä¸º "manual" æˆ–å…¶ä»–ç±»å‹æ—¶ï¼šç»™å‡ºæ¸…æ™°çš„äººå·¥éªŒè¯è¯´æ˜ï¼Œå¿…è¦æ—¶ä¹Ÿå¯ä»¥è¡¥å……è‡ªåŠ¨åŒ–æµ‹è¯•ã€‚
3. å……åˆ†åˆ©ç”¨ä½ åœ¨æœ¬åœ°å¯ç”¨çš„å‘½ä»¤ï¼ˆä¾‹å¦‚ npmã€pnpmã€yarnã€pytestã€go test ç­‰ï¼‰è¿è¡Œæµ‹è¯•ï¼Œç¡®ä¿ç›¸å…³æµ‹è¯•å…¨éƒ¨é€šè¿‡ã€‚
4. éµå¾ªæœ¬ä»“åº“å·²æœ‰çš„ä»£ç é£æ ¼å’Œé¡¹ç›®ç»“æ„ï¼Œå°½é‡ä¿æŒæ”¹åŠ¨æœ€å°ä¸”èšç„¦å½“å‰æ­¥éª¤ã€‚
5. åœ¨å®Œæˆå®ç°å’Œå•å…ƒæµ‹è¯•ç¼–å†™åï¼Œè¯·æ ¹æ®ä½ å®é™…ä½¿ç”¨çš„æµ‹è¯•å‘½ä»¤ï¼Œåœ¨è¾“å‡ºæœ«å°¾é™„åŠ ä¸€ä¸ªä»…åŒ…å« \`unit_test\` å­—æ®µçš„ JSON å¯¹è±¡ï¼Œç”¨äºè®°å½•å¦‚ä½•é‡æ–°è¿è¡Œä¸æœ¬æ­¥éª¤ç›¸å…³çš„å•å…ƒæµ‹è¯•ã€‚æ ¼å¼ç¤ºä¾‹ï¼š

{
  "unit_test": {
    "command": "npm test -- tests/run-command.test.ts",
    "files": ["tests/run-command.test.ts"],
    "notes": "è¦†ç›– runStepsDirectory çš„ä¸»è¦åœºæ™¯"
  }
}

è¦æ±‚ï¼š
- åªè¾“å‡ºä¸Šè¿° JSON å¯¹è±¡ï¼Œä¸è¦ä½¿ç”¨ Markdown ä»£ç å—ï¼›
- JSON ä¸­å¿…é¡»ä½¿ç”¨è‹±æ–‡åŒå¼•å·ï¼›
- å¦‚æœä½ è®¤ä¸ºæœ¬æ­¥éª¤ä¸éœ€è¦æˆ–æ— æ³•ç¼–å†™ä¸“é—¨çš„å•å…ƒæµ‹è¯•ï¼Œå¯ä»¥çœç•¥ \`unit_test\` å­—æ®µï¼ˆä¸è¦è¾“å‡ºç©ºå­—æ®µï¼‰ã€‚

é€€å‡ºçº¦å®šï¼š
- å½“ä¸”ä»…å½“ä½ è®¤ä¸ºå½“å‰æ­¥éª¤å·²ç»å®Œå…¨å®ç°ï¼Œä¸”æ‰€æœ‰ç›¸å…³æµ‹è¯•å‡é€šè¿‡æ—¶ï¼Œæ‰ä»¥é€€å‡ºç  0 æ­£å¸¸ç»“æŸï¼›
- å¦‚æœä½ æ— æ³•å®Œæˆå½“å‰æ­¥éª¤ã€é‡åˆ°æ— æ³•è§£å†³çš„é”™è¯¯ã€æˆ–æœ‰ä»»ä½•æµ‹è¯•å¤±è´¥ï¼Œè¯·ä»¥é 0 é€€å‡ºç ç»“æŸï¼Œå¹¶åœ¨è¾“å‡ºä¸­ç®€è¦è¯´æ˜åŸå› ã€‚

è¯·ç°åœ¨å¼€å§‹æ‰§è¡Œè¯¥æ­¥éª¤ã€‚`;
}

export function appendPreviousFailureContextToPrompt(params: {
  basePrompt: string;
  context?: PreviousAttemptFailureContext;
}): string {
  const { basePrompt, context } = params;
  if (!context) {
    return basePrompt;
  }

  const lines: string[] = [];
  lines.push("");
  lines.push("====== ä¸Šä¸€è½®å°è¯•å¤±è´¥åŸå› æ‘˜è¦ ======");
  lines.push("");
  lines.push(
    `- ä¸Šä¸€è½®å°è¯•åºå·ï¼šç¬¬ ${context.attempt}/${context.maxAttempts} è½®`,
  );
  lines.push(
    `- ä¸Šä¸€è½®æ­¥éª¤çŠ¶æ€å˜åŒ–ï¼š${context.fromStatus} â†’ ${context.toStatus}`,
  );

  if (context.unitTestCommand) {
    lines.push(
      `- æœ€è¿‘ä¸€æ¬¡å•å…ƒæµ‹è¯•å‘½ä»¤ï¼š${context.unitTestCommand}`,
    );
    if (context.unitTestOutputSnippet) {
      lines.push("- å•å…ƒæµ‹è¯•å…³é”®è¾“å‡ºï¼ˆå·²æˆªæ–­ï¼‰ï¼š");
      lines.push(context.unitTestOutputSnippet);
    }
  }

  if (context.verificationError) {
    lines.push(
      `- verification é˜¶æ®µçš„é”™è¯¯ä¿¡æ¯ï¼š${context.verificationError}`,
    );
  }

  if (context.aiError) {
    lines.push(`- AI å®ç°é˜¶æ®µè¿”å›çš„é”™è¯¯ï¼š${context.aiError}`);
  }

  lines.push("");
  lines.push(
    "è¯·åœ¨æœ¬è½®å®ç°ä¸­é‡ç‚¹æ ¹æ®ä¸Šè¿°å¤±è´¥åŸå› è¿›è¡Œæœ‰é’ˆå¯¹æ€§çš„ä¿®å¤ã€‚",
  );

  return `${basePrompt}\n\n${lines.join("\n")}`;
}

function logAttemptFailureSummary(context: PreviousAttemptFailureContext): void {
  const base = `  â„¹ æœ¬è½®å¤±è´¥æ‘˜è¦ï¼šç¬¬ ${context.attempt}/${context.maxAttempts} è½®ï¼Œæ­¥éª¤çŠ¶æ€ ${context.fromStatus} â†’ ${context.toStatus}`;

  if (context.unitTestCommand) {
    console.log(
      chalk.yellow(
        `${base}ï¼Œæœ€è¿‘ä¸€æ¬¡å•å…ƒæµ‹è¯•å‘½ä»¤ "${context.unitTestCommand}" å¤±è´¥`,
      ),
    );
    return;
  }

  if (context.verificationError) {
    console.log(
      chalk.yellow(
        `${base}ï¼Œverification éªŒè¯å¤±è´¥ï¼š${context.verificationError}`,
      ),
    );
    return;
  }

  if (context.aiError) {
    console.log(
      chalk.yellow(
        `${base}ï¼ŒAI å®ç°é˜¶æ®µè¿”å›é”™è¯¯ï¼š${context.aiError}`,
      ),
    );
    return;
  }

  console.log(chalk.yellow(base));
}

function buildRunStepValidationPrompt(params: {
  projectRoot: string;
  stepsDir: string;
  step: StepJson;
  fileName: string;
  order: number;
  total: number;
}): string {
  const { projectRoot, stepsDir, step, fileName, order, total } = params;

  const verificationLines =
    step.verification.length > 0
      ? step.verification
          .map(
            (v, index) =>
              `${index + 1}. [${v.type}] ${v.description}`,
          )
          .join("\n")
      : "ï¼ˆå½“å‰æ­¥éª¤æ²¡æœ‰æ˜¾å¼çš„ verification æ¡ç›®ï¼Œä½†ä½ ä»éœ€è¦æ ¹æ®æè¿°é€‰æ‹©åˆç†çš„æµ‹è¯•æˆ–éªŒè¯æ–¹å¼ã€‚ï¼‰";

  return `ä½ æ˜¯ agent-foreman å·¥ç¨‹ä¸­çš„æµ‹è¯•éªŒè¯åŠ©æ‰‹ï¼Œè´Ÿè´£åœ¨æœ¬åœ°ä»£ç ä»“åº“ä¸­æ ¹æ®æ­¥éª¤æè¿°å’Œ verification åˆ—è¡¨é‡æ–°è¿è¡Œæµ‹è¯•ï¼Œè¿›è¡Œå›å½’éªŒè¯ã€‚

å½“å‰é¡¹ç›®æ ¹ç›®å½•ï¼ˆå·¥ä½œç›®å½•ï¼‰ä¸ºï¼š
${projectRoot}

æ­¥éª¤æ–‡ä»¶æ‰€åœ¨ç›®å½•ä¸ºï¼š
${stepsDir}

æœ¬æ¬¡è¦éªŒè¯çš„æ­¥éª¤ä¿¡æ¯å¦‚ä¸‹ï¼š
- é¡ºåºï¼šç¬¬ ${order} æ­¥ / å…± ${total} æ­¥
- æ­¥éª¤æ–‡ä»¶ï¼š${fileName}
- æ­¥éª¤ IDï¼š${step.id}
- å½“å‰æ­¥éª¤åœ¨ JSON ä¸­çš„çŠ¶æ€ï¼š${step.status}
- æè¿°ï¼ˆdescriptionï¼‰ï¼š
${step.description}

éªŒè¯é¡¹ç›®ï¼ˆverificationï¼‰åˆ—è¡¨å¦‚ä¸‹ï¼Œè¯·åŠ¡å¿…å…¨éƒ¨è¦†ç›–ï¼š
${verificationLines}

ä½ çš„ä»»åŠ¡ï¼ˆä»…é™æµ‹è¯•éªŒè¯ï¼Œä¸å…è®¸ä¿®æ”¹ä»»ä½•ä»£ç æˆ–é…ç½®ï¼‰ï¼š
1. åªæ ¹æ®ä¸Šè¿°æè¿°å’Œ verification æ¡ç›®ï¼Œé€‰æ‹©å¹¶æ‰§è¡Œåˆé€‚çš„æµ‹è¯•å‘½ä»¤ï¼ˆä¾‹å¦‚ npm test / pnpm test / è‡ªå®šä¹‰è„šæœ¬ç­‰ï¼‰ï¼ŒéªŒè¯è¯¥æ­¥éª¤å¯¹åº”çš„åŠŸèƒ½æ˜¯å¦ä»ç„¶æ­£ç¡®ã€‚
2. ä½ å¯ä»¥é˜…è¯»ä»£ç å’Œæµ‹è¯•æ–‡ä»¶ï¼Œä½†ç¦æ­¢ä¿®æ”¹ä»»ä½•æºä»£ç ã€é…ç½®æ–‡ä»¶ã€æµ‹è¯•æ–‡ä»¶æˆ–æ–‡æ¡£å†…å®¹â€”â€”æœ¬è½®ä»…åšã€Œå›å½’éªŒè¯ã€ï¼Œä¸åšå®ç°æ”¹åŠ¨ã€‚
3. å¦‚æœä½ è®¤ä¸ºæ‰€æœ‰ä¸æœ¬æ­¥éª¤ç›¸å…³çš„æµ‹è¯•å‡å·²è¦†ç›–ä¸”å…¨éƒ¨é€šè¿‡ï¼Œåˆ™ä»¥é€€å‡ºç  0 æ­£å¸¸ç»“æŸã€‚
4. å¦‚æœæœ‰ä»»æ„æµ‹è¯•å¤±è´¥ã€å‘ç°æ˜æ˜¾ç¼ºé™·ã€æˆ–ä½ æ— æ³•ç¡®è®¤è¯¥æ­¥éª¤å·²ç»å®Œå…¨æ»¡è¶³æè¿°å’Œ verification è¦æ±‚ï¼Œè¯·ä»¥é 0 é€€å‡ºç ç»“æŸï¼Œå¹¶åœ¨è¾“å‡ºä¸­ç®€è¦è¯´æ˜å¤±è´¥åŸå› æˆ–é£é™©ç‚¹ã€‚

é€€å‡ºçº¦å®šï¼š
- é€€å‡ºç  0ï¼šè¡¨ç¤ºæœ¬æ¬¡å›å½’éªŒè¯é€šè¿‡ï¼Œå½“å‰æ­¥éª¤å¯ä»¥ç»§ç»­ä¿æŒä¸ºâ€œğŸŸ¢ å·²å®Œæˆâ€çŠ¶æ€ï¼›
- é 0 é€€å‡ºç ï¼šè¡¨ç¤ºæœ¬æ¬¡å›å½’éªŒè¯æœªé€šè¿‡æˆ–å­˜åœ¨ä¸ç¡®å®šæ€§ï¼Œè°ƒç”¨æ–¹ä¼šæ ¹æ®éœ€è¦é‡æ–°æ‰“å¼€æ­¥éª¤å¹¶è¿›å…¥å®ç°é˜¶æ®µã€‚

è¯·ç°åœ¨å¼€å§‹æ‰§è¡Œå›å½’éªŒè¯ï¼Œä»…è¿è¡Œæµ‹è¯•å’Œæ£€æŸ¥ç»“æœï¼Œä¸è¦ä¿®æ”¹ä»»ä½•ä»£ç æˆ–é…ç½®ã€‚`;
}

async function discoverStepFiles(stepsDir: string): Promise<{
  stepFiles: string[];
  otherJsonFiles: string[];
}> {
  const entries = await fs.readdir(stepsDir);
  const jsonFiles = entries.filter((name) => name.toLowerCase().endsWith(".json"));

  if (jsonFiles.length === 0) {
    throw new Error("æ­¥éª¤ç›®å½•ä¸­æœªæ‰¾åˆ°ä»»ä½• JSON æ­¥éª¤æ–‡ä»¶");
  }

  const stepPattern = /^\d{3}-.+\.json$/;
  const stepFiles = jsonFiles.filter((name) => stepPattern.test(name));
  const otherJsonFiles = jsonFiles.filter((name) => !stepPattern.test(name));

  if (stepFiles.length === 0) {
    throw new Error(
      `åœ¨æ­¥éª¤ç›®å½•ä¸­æœªæ‰¾åˆ°ç¬¦åˆ "NNN-*.json" å‘½åè§„åˆ™çš„æ­¥éª¤æ–‡ä»¶ï¼Œæ‰¾åˆ°çš„ JSON æ–‡ä»¶æœ‰ï¼š${jsonFiles.join(
        ", ",
      )}`,
    );
  }

  stepFiles.sort((a, b) => a.localeCompare(b));

  return { stepFiles, otherJsonFiles };
}

export async function loadStepEntries(
  stepsDir: string,
  stepFiles: string[],
): Promise<{ entries: RunStepEntry[]; hasParseError: boolean }> {
  const entries: RunStepEntry[] = [];
  let hasParseError = false;

  for (let index = 0; index < stepFiles.length; index++) {
    const fileName = stepFiles[index];
    const filePath = path.join(stepsDir, fileName);
    const prefix = fileName.slice(0, 3);
    const order = index + 1;
    const entry: RunStepEntry = {
      order,
      prefix,
      fileName,
      filePath,
    };

    try {
      const content = await fs.readFile(filePath, "utf-8");
      let parsed: unknown;
      try {
        parsed = JSON.parse(content);
      } catch (err) {
        throw new Error(
          err instanceof Error ? `JSON è§£æå¤±è´¥ï¼š${err.message}` : "JSON è§£æå¤±è´¥",
        );
      }

      if (!isStepJson(parsed)) {
        throw new Error("JSON ç»“æ„ä¸ç¬¦åˆæ­¥éª¤æ–‡ä»¶è¦æ±‚");
      }

      const step = parsed as StepJson;

      entry.id = step.id;
      entry.description = step.description;
      entry.initialStatus = step.status;
      entry.finalStatus = step.status;
      entry.verification = step.verification;
      entry.unitTest = step.unit_test;

      const expectedId = `step-${prefix}`;
      if (step.id !== expectedId) {
        console.log(
          chalk.yellow(
            `âš  æ­¥éª¤æ–‡ä»¶ ${fileName} çš„ id å­—æ®µä¸º "${step.id}"ï¼Œä¸æ–‡ä»¶åå‰ç¼€ "${prefix}" ä¸ä¸€è‡´ï¼ˆé¢„æœŸä¸º "${expectedId}"ï¼‰`,
          ),
        );
      }
    } catch (err) {
      hasParseError = true;
      const message =
        err instanceof Error ? err.message : "æœªçŸ¥é”™è¯¯ï¼Œæ— æ³•è§£ææ­¥éª¤ JSON æ–‡ä»¶";
      entry.parseError = message;
      entry.error = message;
      console.log(
        chalk.red(
          `âœ— æ— æ³•è§£ææ­¥éª¤æ–‡ä»¶ ${fileName}: ${message}`,
        ),
      );
    }

    entries.push(entry);
  }

  return { entries, hasParseError };
}

export async function writeProgressMarkdown(params: {
  stepsDir: string;
  entries: RunStepEntry[];
  startedAt: Date;
  finishedAt: Date;
}): Promise<string> {
  const { stepsDir, entries, startedAt, finishedAt } = params;

  const fileName = "run-progress.md";
  const filePath = path.join(stepsDir, fileName);

  const total = entries.length;
  const successCount = entries.filter((e) => e.success).length;
  const failureCount = entries.filter((e) => e.success === false).length;

  const lines: string[] = [];

  lines.push(`# agent-foreman run æ‰§è¡Œè¿›åº¦æŠ¥å‘Š`);
  lines.push("");
  lines.push(`- æ­¥éª¤ç›®å½•: \`${stepsDir}\``);
  lines.push(`- å¼€å§‹æ—¶é—´: ${formatDateTime(startedAt)}`);
  lines.push(`- ç»“æŸæ—¶é—´: ${formatDateTime(finishedAt)}`);
  lines.push(`- æ€»æ­¥éª¤æ•°: ${total}`);
  lines.push(`- æˆåŠŸæ­¥éª¤æ•°: ${successCount}`);
  lines.push(`- å¤±è´¥æ­¥éª¤æ•°: ${failureCount}`);
  lines.push("");

  lines.push("## æ­¥éª¤æ˜ç»†");
  lines.push("");
  lines.push("| é¡ºåº | æ–‡ä»¶å | æ­¥éª¤ ID | æ‰§è¡Œå‰çŠ¶æ€ | æ‰§è¡ŒåçŠ¶æ€ | ç»“æœ | æ‘˜è¦ | é”™è¯¯ä¿¡æ¯ |");
  lines.push("| ---- | ------ | ------- | ---------- | ---------- | ---- | ---- | -------- |");

  for (const entry of entries) {
    const before = entry.initialStatus ?? "";
    const after = entry.finalStatus ?? before;
    const result =
      entry.success === true
        ? "æˆåŠŸ"
        : entry.success === false
          ? "å¤±è´¥"
          : "æœªæ‰§è¡Œ";
    const summary = entry.description
      ? truncateDescription(entry.description, 60).replace(/\|/g, "\\|")
      : "";
    const error = entry.error
      ? truncateDescription(entry.error, 80).replace(/\|/g, "\\|")
      : "";

    lines.push(
      `| ${entry.order
        .toString()
        .padStart(3, " ")} | ${entry.fileName} | ${entry.id ?? ""} | ${before} | ${after} | ${result} | ${summary} | ${error} |`,
    );
  }

  const content = `${lines.join("\n")}\n`;
  await fs.writeFile(filePath, content, "utf-8");

  return filePath;
}

export function extractUnitTestFromOutput(output: string): StepUnitTest | undefined {
  const jsonStr = extractJsonObject(output);
  if (!jsonStr) return undefined;

  let parsed: unknown;
  try {
    parsed = JSON.parse(jsonStr);
  } catch {
    return undefined;
  }

  if (!parsed || typeof parsed !== "object") return undefined;

  const obj = parsed as { unit_test?: unknown };
  const rawUnit = obj.unit_test;
  if (!rawUnit || typeof rawUnit !== "object") return undefined;

  const u = rawUnit as { command?: unknown; files?: unknown; notes?: unknown };

  if (typeof u.command !== "string" || !u.command.trim()) return undefined;
  const command = u.command.trim();

  let files: string[] | undefined;
  if (Array.isArray(u.files)) {
    files = u.files.filter((f): f is string => typeof f === "string" && f.trim().length > 0);
  }

  const notes = typeof u.notes === "string" && u.notes.trim().length > 0 ? u.notes.trim() : undefined;

  return { command, files, notes };
}

async function runUnitTestsForStep(
  unitTest: StepUnitTest,
  cwd: string,
): Promise<{ success: boolean; error?: string; output?: string }> {
  const result = spawnSync(unitTest.command, {
    cwd,
    shell: true,
    encoding: "utf-8",
  });

  const stdout = (result.stdout || "").toString();
  const stderr = (result.stderr || "").toString();
  const combined = `${stdout}${stdout && stderr ? "\n" : ""}${stderr}`;

  if (result.status === 0) {
    return { success: true, output: combined };
  }

  const message =
    combined.trim() || `Unit test command exited with code ${result.status ?? "unknown"}`;

  return {
    success: false,
    error: message,
    output: combined,
  };
}

const MAX_ATTEMPTS = 5;

export async function runStepsDirectory(
  stepsDirArg: string,
  options: RunStepsOptions = {},
): Promise<void> {
  const cwd = process.cwd();
  const stepsDir = path.isAbsolute(stepsDirArg)
    ? stepsDirArg
    : path.join(cwd, stepsDirArg);

  const startedAt = new Date();

  let stat;
  try {
    stat = await fs.stat(stepsDir);
  } catch {
    console.log(chalk.red(`âœ— æ­¥éª¤ç›®å½•ä¸å­˜åœ¨ï¼š${stepsDirArg}`));
    process.exitCode = 1;
    return;
  }

  if (!stat.isDirectory()) {
    console.log(chalk.red(`âœ— æä¾›çš„è·¯å¾„ä¸æ˜¯ç›®å½•ï¼š${stepsDirArg}`));
    process.exitCode = 1;
    return;
  }

  let stepFiles: string[];
  let otherJsonFiles: string[];

  try {
    const discovered = await discoverStepFiles(stepsDir);
    stepFiles = discovered.stepFiles;
    otherJsonFiles = discovered.otherJsonFiles;
  } catch (err) {
    const message =
      err instanceof Error ? err.message : "æ— æ³•å‘ç°æ­¥éª¤ JSON æ–‡ä»¶";
    console.log(chalk.red(`âœ— ${message}`));
    process.exitCode = 1;
    return;
  }

  if (otherJsonFiles.length > 0) {
    console.log(
      chalk.yellow(
        `âš  å‘ç° ${otherJsonFiles.length} ä¸ªå‘½åä¸ç¬¦åˆ "NNN-*.json" è§„åˆ™çš„ JSON æ–‡ä»¶ï¼Œå®ƒä»¬ä¸ä¼šä½œä¸ºæ­¥éª¤æ‰§è¡Œï¼š${otherJsonFiles.join(
          ", ",
        )}`,
      ),
    );
  }

  console.log(
    chalk.blue(
      `ğŸ§© å³å°†æ‰§è¡Œ ${stepFiles.length} ä¸ªæ­¥éª¤ï¼ˆç›®å½•ï¼š${stepsDirArg}ï¼‰`,
    ),
  );
  console.log(
    chalk.gray(
      `  æ‰§è¡Œé¡ºåºï¼ˆå‰å‡ é¡¹é¢„è§ˆï¼‰ï¼š${stepFiles
        .slice(0, 5)
        .join(", ")}${stepFiles.length > 5 ? " ..." : ""}`,
    ),
  );

  const { entries, hasParseError } = await loadStepEntries(stepsDir, stepFiles);

  if (hasParseError) {
    console.log(
      chalk.red(
        "âœ— æœ‰æ­¥éª¤ JSON æ–‡ä»¶ç»“æ„ä¸åˆæ³•ï¼Œå·²ä¸­æ­¢æ‰§è¡Œã€‚è¯·ä¿®æ­£ä¸Šè¿°é”™è¯¯åé‡è¯•ã€‚",
      ),
    );
    const finishedAt = new Date();
    const progressPath = await writeProgressMarkdown({
      stepsDir,
      entries,
      startedAt,
      finishedAt,
    });
    console.log(chalk.gray(`  æ‰§è¡Œè¿›åº¦æŠ¥å‘Šå·²å†™å…¥ï¼š${progressPath}`));
    process.exitCode = 1;
    return;
  }

  const verifyOnly = options.verifyOnly === true;
  const verifyUnitTestOnly = options.verifyUnitTestOnly === true;
  const verifyGenerateUnitTest = options.verifyGenerateUnitTest === true;
  const fullVerify = options.fullVerify === true;

  const enabledModesCount = [
    verifyOnly,
    verifyUnitTestOnly,
    verifyGenerateUnitTest,
    fullVerify,
  ].filter(Boolean).length;

  if (enabledModesCount > 1) {
    console.log(
      chalk.red(
        "âœ— runStepsDirectory é€‰é¡¹å†²çªï¼šfullVerifyã€verifyOnlyã€verifyUnitTestOnlyã€verifyGenerateUnitTest ä¸èƒ½åŒæ—¶å¯ç”¨å¤šä¸ªã€‚",
      ),
    );
    process.exitCode = 1;
    return;
  }

  const mode: "normal" | "full-verify" | "verify-only" | "verify-unit-test-only" | "verify-generate-unit-test" =
    verifyOnly
      ? "verify-only"
      : verifyUnitTestOnly
        ? "verify-unit-test-only"
        : verifyGenerateUnitTest
          ? "verify-generate-unit-test"
          : fullVerify
            ? "full-verify"
            : "normal";

  const total = entries.length;
  let firstFailure: RunStepEntry | undefined;

  for (const entry of entries) {
    if (!entry.id || !entry.description || !entry.verification) {
      // Should not happen if loadStepEntries passed validation, but keep safe
      entry.success = false;
      entry.error = "æ­¥éª¤å…ƒæ•°æ®ä¸å®Œæ•´ï¼Œæ— æ³•æ‰§è¡Œ";
      firstFailure = firstFailure ?? entry;
      break;
    }

    const step: StepJson = {
      id: entry.id,
      description: entry.description,
      status: entry.initialStatus ?? "ğŸ”´ å¾…å®Œæˆ",
      verification: entry.verification,
    };
    if (entry.unitTest) {
      step.unit_test = entry.unitTest;
    }

    console.log("");
    console.log(
      chalk.bold(
        `[${entry.order}/${total}] ${entry.fileName} (${step.id})`,
      ),
    );
    console.log(
      chalk.gray(
        `  æè¿°: ${truncateDescription(step.description)}`,
      ),
    );
    console.log(
      chalk.gray(
        `  å½“å‰çŠ¶æ€: ${step.status}`,
      ),
    );

    if (mode === "verify-generate-unit-test") {
      console.log(
        chalk.gray(
          "  å½“å‰è¿è¡Œæ¨¡å¼ï¼šä»…æ£€æŸ¥å¹¶ä¸ºç¼ºå°‘é…ç½®çš„æ­¥éª¤ç”Ÿæˆ unit_testã€‚",
        ),
      );

      if (entry.unitTest && entry.unitTest.command) {
        console.log(
          chalk.gray(
            `  å·²å­˜åœ¨ unit_test é…ç½®ï¼Œå‘½ä»¤ï¼š${entry.unitTest.command}ï¼Œè·³è¿‡ç”Ÿæˆã€‚`,
          ),
        );
        entry.finalStatus = step.status;
        entry.success = true;
        entry.error = undefined;
        continue;
      }

      console.log(
        chalk.gray(
          "  å½“å‰æ­¥éª¤å°šæœªé…ç½® unit_testï¼Œå°†å°è¯•è°ƒç”¨å‘½ä»¤è¡Œ AI ç”Ÿæˆå•å…ƒæµ‹è¯•å¹¶å†™å…¥æ­¥éª¤ JSON...",
        ),
      );

      const basePrompt = buildRunStepPrompt({
        projectRoot: cwd,
        stepsDir,
        step,
        fileName: entry.fileName,
        order: entry.order,
        total,
      });
      const generatePrompt = `${basePrompt}

====== é‡è¦æ¨¡å¼è¯´æ˜ï¼šä»…ç”Ÿæˆå•å…ƒæµ‹è¯• ======

å½“å‰è¿è¡Œåœ¨ \`--verify-generate-unittest\` æ¨¡å¼ä¸‹ï¼Œæœ¬è½®ä»»åŠ¡åªå…è®¸ï¼š
- ä¸ºå½“å‰æ­¥éª¤è¡¥å……æˆ–ç”Ÿæˆå•å…ƒæµ‹è¯•ä»£ç ï¼›
- è¿è¡Œå¿…è¦çš„æµ‹è¯•å‘½ä»¤ç¡®è®¤å•å…ƒæµ‹è¯•å¯æ‰§è¡Œï¼›
- åœ¨è¾“å‡ºæœ«å°¾é™„åŠ åŒ…å« \`unit_test\` å­—æ®µçš„ JSONï¼ˆä¸æ™®é€šå®ç°æ¨¡å¼ä¸€è‡´ï¼‰ã€‚

ç¦æ­¢äº‹é¡¹ï¼š
- ä¸è¦å¯¹ä¸šåŠ¡å®ç°ä»£ç åšä¸æµ‹è¯•æ— å…³çš„æ”¹åŠ¨ï¼›
- ä¸è¦å°è¯•å®ç°æ–°çš„åŠŸèƒ½é€»è¾‘ï¼Œåªé’ˆå¯¹å·²æœ‰å®ç°ç¼–å†™æˆ–å®Œå–„å•å…ƒæµ‹è¯•ã€‚`;

      const result = await callAnyAvailableAgent(generatePrompt, {
        cwd,
        verbose: true,
      });

      if (!result.success) {
        const errorMessage = result.error || "ç”Ÿæˆå•å…ƒæµ‹è¯•å¤±è´¥";
        console.log(chalk.red(`  âœ— æ— æ³•ç”Ÿæˆå•å…ƒæµ‹è¯•ï¼š${errorMessage}`));
        entry.finalStatus = step.status;
        entry.success = false;
        entry.error = errorMessage;
        firstFailure = firstFailure ?? entry;
        break;
      }

      const unitTest = extractUnitTestFromOutput(result.output);
      if (!unitTest) {
        const errorMessage = "AI è¾“å‡ºä¸­æœªæ‰¾åˆ°åˆæ³•çš„ unit_test é…ç½®";
        console.log(chalk.red(`  âœ— ${errorMessage}`));
        entry.finalStatus = step.status;
        entry.success = false;
        entry.error = errorMessage;
        firstFailure = firstFailure ?? entry;
        break;
      }

      step.unit_test = unitTest;
      entry.unitTest = unitTest;

      try {
        await fs.writeFile(entry.filePath, JSON.stringify(step, null, 2), "utf-8");
      } catch (err) {
        const message =
          err instanceof Error ? err.message : "æ— æ³•å†™å…¥æ­¥éª¤ JSON æ–‡ä»¶";
        console.log(
          chalk.red(
            `âœ— æ­¥éª¤å·²æˆåŠŸç”Ÿæˆå•å…ƒæµ‹è¯•ï¼Œä½†å†™å›çŠ¶æ€åˆ°æ–‡ä»¶æ—¶å¤±è´¥ï¼š${message}`,
          ),
        );
        entry.finalStatus = step.status;
        entry.success = false;
        entry.error = message;
        firstFailure = firstFailure ?? entry;
        break;
      }

      console.log(
        chalk.green(
          `  âœ“ å•å…ƒæµ‹è¯•å·²ç”Ÿæˆå¹¶å†™å…¥æ­¥éª¤ JSONï¼ˆå‘½ä»¤ï¼š${unitTest.command}ï¼‰`,
        ),
      );

      entry.finalStatus = step.status;
      entry.success = true;
      entry.error = undefined;
      continue;
    }

    if (mode === "verify-unit-test-only") {
      console.log(
        chalk.gray(
          "  å½“å‰è¿è¡Œæ¨¡å¼ï¼šä»…æ‰§è¡Œ unit_test ä¸­å®šä¹‰çš„å•å…ƒæµ‹è¯•ï¼Œä¸åšå®ç°æˆ– AI verificationã€‚",
        ),
      );

      if (!entry.unitTest || !entry.unitTest.command) {
        const errorMessage = "æœªé…ç½® unit_testï¼Œæ— æ³•æ‰§è¡Œå•å…ƒæµ‹è¯•";
        console.log(chalk.red(`  âœ— ${errorMessage}`));
        entry.finalStatus = step.status;
        entry.success = false;
        entry.error = errorMessage;
        firstFailure = firstFailure ?? entry;
        break;
      }

      console.log(
        chalk.gray(
          `  ğŸ§ª æ‰§è¡Œå•å…ƒæµ‹è¯•: ${entry.unitTest.command}`,
        ),
      );
      const testResult = await runUnitTestsForStep(entry.unitTest, cwd);
      if (!testResult.success) {
        console.log(chalk.red("  âœ— å•å…ƒæµ‹è¯•å¤±è´¥"));
        if (testResult.error) {
          testResult.error
            .split("\n")
            .slice(0, 10)
            .forEach((line) => {
              if (line.trim()) {
                console.log(chalk.red(`    ${line}`));
              }
            });
        }

        if (step.status !== "ğŸ”´ å¾…å®Œæˆ") {
          step.status = "ğŸ”´ å¾…å®Œæˆ";
        }
        entry.finalStatus = step.status;
        entry.success = false;
        entry.error = "å•å…ƒæµ‹è¯•å¤±è´¥";

        try {
          await fs.writeFile(
            entry.filePath,
            JSON.stringify(step, null, 2),
            "utf-8",
          );
        } catch (err) {
          const message =
            err instanceof Error ? err.message : "æ— æ³•å†™å…¥æ­¥éª¤ JSON æ–‡ä»¶";
          console.log(
            chalk.red(
              `âœ— æ— æ³•å†™å›å¤±è´¥çŠ¶æ€åˆ°æ­¥éª¤æ–‡ä»¶ï¼š${message}`,
            ),
          );
        }

        firstFailure = firstFailure ?? entry;
        break;
      }

      console.log(chalk.green("  âœ“ å•å…ƒæµ‹è¯•é€šè¿‡"));
      entry.finalStatus = step.status;
      entry.success = true;
      entry.error = undefined;
      continue;
    }

    if (mode === "verify-only") {
      console.log(
        chalk.gray(
          "  å½“å‰è¿è¡Œæ¨¡å¼ï¼šä»…æ‰§è¡Œå•å…ƒæµ‹è¯•å’Œ verificationï¼Œä¸åšå®ç°æ”¹åŠ¨ã€‚",
        ),
      );

      let testsFailed = false;
      let failureMessage: string | undefined;

      if (entry.unitTest && entry.unitTest.command) {
        console.log(
          chalk.gray(
            `  ğŸ§ª æ‰§è¡Œå•å…ƒæµ‹è¯•: ${entry.unitTest.command}`,
          ),
        );
        const testResult = await runUnitTestsForStep(entry.unitTest, cwd);
        if (!testResult.success) {
          console.log(chalk.red("  âœ— å•å…ƒæµ‹è¯•å¤±è´¥"));
          if (testResult.error) {
            testResult.error
              .split("\n")
              .slice(0, 10)
              .forEach((line) => {
                if (line.trim()) {
                  console.log(chalk.red(`    ${line}`));
                }
              });
          }
          testsFailed = true;
          failureMessage = "å•å…ƒæµ‹è¯•å¤±è´¥";
        } else {
          console.log(chalk.green("  âœ“ å•å…ƒæµ‹è¯•é€šè¿‡"));
        }
      }

      if (!testsFailed) {
        const validationPrompt = buildRunStepValidationPrompt({
          projectRoot: cwd,
          stepsDir,
          step,
          fileName: entry.fileName,
          order: entry.order,
          total,
        });

        console.log(
          chalk.gray("  æ­£åœ¨è°ƒç”¨å‘½ä»¤è¡Œ AI æŒ‰ verification è¿›è¡ŒéªŒè¯..."),
        );

        const validationResult = await callAnyAvailableAgent(
          validationPrompt,
          {
            cwd,
            verbose: true,
          },
        );

        if (!validationResult.success) {
          const verificationError =
            validationResult.error || "verification éªŒè¯å¤±è´¥";
          failureMessage = verificationError;
        } else {
          console.log(chalk.green("  âœ“ verification éªŒè¯é€šè¿‡"));
        }
      }

      if (failureMessage) {
        console.log(chalk.red(`  âœ— éªŒè¯å¤±è´¥ï¼š${failureMessage}`));
        if (step.status !== "ğŸ”´ å¾…å®Œæˆ") {
          step.status = "ğŸ”´ å¾…å®Œæˆ";
        }
        entry.finalStatus = step.status;
        entry.success = false;
        entry.error = failureMessage;

        try {
          await fs.writeFile(
            entry.filePath,
            JSON.stringify(step, null, 2),
            "utf-8",
          );
        } catch (err) {
          const message =
            err instanceof Error ? err.message : "æ— æ³•å†™å›å¤±è´¥çŠ¶æ€åˆ°æ­¥éª¤æ–‡ä»¶";
          console.log(
            chalk.red(
              `âœ— æ— æ³•å†™å›å¤±è´¥çŠ¶æ€åˆ°æ­¥éª¤æ–‡ä»¶ï¼š${message}`,
            ),
          );
        }

        firstFailure = firstFailure ?? entry;
        break;
      }

      console.log(
        chalk.green("  âœ“ å•å…ƒæµ‹è¯•å’Œ verification å‡é€šè¿‡ï¼ˆæœªè¿›è¡Œå®ç°ï¼‰ã€‚"),
      );
      entry.finalStatus = step.status;
      entry.success = true;
      entry.error = undefined;
      continue;
    }

    let needImplementation = step.status !== "ğŸŸ¢ å·²å®Œæˆ";

    // å¦‚æœå½“å‰ä¸ºå·²å®ŒæˆçŠ¶æ€ï¼Œä¸”å¼€å¯äº† fullVerifyï¼Œåˆ™å…ˆè¿›è¡Œä¸€æ¬¡ã€Œä»…æµ‹è¯•ã€çš„å›å½’éªŒè¯
    if (step.status === "ğŸŸ¢ å·²å®Œæˆ" && mode === "full-verify") {
      console.log(
        chalk.gray(
          "  å½“å‰æ­¥éª¤å·²æ ‡è®°ä¸ºå·²å®Œæˆï¼Œå°†ä»…é‡æ–°è¿è¡Œæµ‹è¯•è¿›è¡Œå›å½’éªŒè¯...",
        ),
      );

      // å¦‚æœæ­¥éª¤åŒ…å« unit_test ä¿¡æ¯ï¼Œå…ˆæŒ‰å…¶å†…å®¹è¿è¡Œå•å…ƒæµ‹è¯•
      if (entry.unitTest && entry.unitTest.command) {
        console.log(
          chalk.gray(
            `  ğŸ§ª æ‰§è¡Œå•å…ƒæµ‹è¯•: ${entry.unitTest.command}`,
          ),
        );
        const testResult = await runUnitTestsForStep(entry.unitTest, cwd);
        if (testResult.success) {
          console.log(chalk.green("  âœ“ å•å…ƒæµ‹è¯•é€šè¿‡"));
        } else {
          console.log(chalk.red("  âœ— å•å…ƒæµ‹è¯•å¤±è´¥"));
          if (testResult.error) {
            testResult.error
              .split("\n")
              .slice(0, 10)
              .forEach((line) => {
                if (line.trim()) {
                  console.log(chalk.red(`    ${line}`));
                }
              });
          }

          entry.finalStatus = step.status;
          entry.success = false;
          entry.error = "å•å…ƒæµ‹è¯•å¤±è´¥";

          const now = new Date();
          await writeProgressMarkdown({
            stepsDir,
            entries,
            startedAt,
            finishedAt: now,
          });

          console.log(
            chalk.yellow(
              "  âš  å•å…ƒæµ‹è¯•æœªé€šè¿‡ï¼Œå°†é‡æ–°æ‰“å¼€è¯¥æ­¥éª¤å¹¶è¿›å…¥å®ç°é˜¶æ®µ...",
            ),
          );
          needImplementation = true;
        }
      }

      // å¦‚æœå•å…ƒæµ‹è¯•é€šè¿‡ï¼ˆæˆ–ä¸å­˜åœ¨ï¼‰ï¼Œå†è°ƒç”¨ AI æŒ‰ verification åšå›å½’éªŒè¯
      if (!needImplementation) {
        const validationPrompt = buildRunStepValidationPrompt({
          projectRoot: cwd,
          stepsDir,
          step,
          fileName: entry.fileName,
          order: entry.order,
          total,
        });

        console.log(chalk.gray("  æ­£åœ¨è°ƒç”¨å‘½ä»¤è¡Œ AI è¿›è¡Œå›å½’æµ‹è¯•éªŒè¯..."));

        const validationResult = await callAnyAvailableAgent(validationPrompt, {
          cwd,
          verbose: true,
        });

        if (validationResult.success) {
          // å›å½’æµ‹è¯•é€šè¿‡ï¼Œä¿æŒçŠ¶æ€ä¸ºå·²å®Œæˆï¼Œä¸è¿›å…¥å®ç°é˜¶æ®µ
          entry.finalStatus = step.status;
          entry.success = true;
          entry.error = undefined;
          console.log(
            chalk.green(
              "  âœ“ å›å½’æµ‹è¯•é€šè¿‡ï¼Œä¿æŒçŠ¶æ€ä¸ºï¼šğŸŸ¢ å·²å®Œæˆ",
            ),
          );

          // æ›´æ–°è¿›åº¦æŠ¥å‘Š
          const now = new Date();
          await writeProgressMarkdown({
            stepsDir,
            entries,
            startedAt,
            finishedAt: now,
          });
          continue;
        }

        console.log(
          chalk.yellow(
            `  âš  å›å½’æµ‹è¯•æœªé€šè¿‡æˆ–å­˜åœ¨é—®é¢˜ï¼ˆ${validationResult.error ?? "åŸå› æœªçŸ¥"}ï¼‰ï¼Œå°†é‡æ–°æ‰“å¼€è¯¥æ­¥éª¤å¹¶è¿›å…¥å®ç°é˜¶æ®µ...`,
          ),
        );
        needImplementation = true;
      }
    }

    if (!needImplementation) {
      continue;
    }

    let shouldAbortRun = false;
    let lastFailureContext: PreviousAttemptFailureContext | undefined;

    for (let attempt = 1; attempt <= MAX_ATTEMPTS; attempt++) {
      const attemptStartStatus = step.status;
      // æ ‡è®°ä¸ºè¿›è¡Œä¸­
      const previousStatus = step.status;
      step.status = "ğŸŸ¡ è¿›è¡Œä¸­";
      entry.finalStatus = step.status;

      try {
        await fs.writeFile(
          entry.filePath,
          JSON.stringify(step, null, 2),
          "utf-8",
        );
      } catch (err) {
        const message =
          err instanceof Error ? err.message : "æ— æ³•å†™å…¥æ­¥éª¤ JSON æ–‡ä»¶";
        console.log(
          chalk.red(
            `âœ— æ— æ³•æ›´æ–°æ­¥éª¤æ–‡ä»¶ ${entry.fileName}: ${message}`,
          ),
        );
        entry.success = false;
        entry.error = message;
        firstFailure = firstFailure ?? entry;

        const now = new Date();
        await writeProgressMarkdown({
          stepsDir,
          entries,
          startedAt,
          finishedAt: now,
        });
        shouldAbortRun = true;
        break;
      }

      console.log(
        chalk.gray(
          `  çŠ¶æ€æ›´æ–°: ${previousStatus} â†’ ${step.status}`,
        ),
      );

      const attemptPrefix = `[${entry.order}/${total}]`;
      if (attempt === 1) {
        console.log(
          chalk.gray(
            `  ğŸ” ${attemptPrefix} ç¬¬ ${attempt}/${MAX_ATTEMPTS} æ¬¡å°è¯•æ‰§è¡Œè¯¥æ­¥éª¤ï¼ˆé¦–æ¬¡å°è¯•ï¼‰...`,
          ),
        );
      } else {
        console.log(
          chalk.gray(
            `  ğŸ” ${attemptPrefix} ç¬¬ ${attempt}/${MAX_ATTEMPTS} æ¬¡å°è¯•æ‰§è¡Œè¯¥æ­¥éª¤ï¼ˆä¸Šä¸€è½®å¤±è´¥ï¼Œå°†åŸºäºå¤±è´¥åŸå› è¿›è¡Œä¿®å¤ï¼‰...`,
          ),
        );
      }

      const basePrompt = buildRunStepPrompt({
        projectRoot: cwd,
        stepsDir,
        step,
        fileName: entry.fileName,
        order: entry.order,
        total,
      });

      const prompt =
        attempt > 1 && lastFailureContext
          ? appendPreviousFailureContextToPrompt({
              basePrompt,
              context: lastFailureContext,
            })
          : basePrompt;

      console.log(chalk.gray("  æ­£åœ¨è°ƒç”¨å‘½ä»¤è¡Œ AI å¤„ç†è¯¥æ­¥éª¤..."));

      const result = await callAnyAvailableAgent(prompt, {
        cwd,
        verbose: true,
      });

      if (result.success) {
        step.status = "ğŸŸ¢ å·²å®Œæˆ";
        entry.finalStatus = step.status;
        entry.success = true;
        entry.error = undefined;

        const unitTest = extractUnitTestFromOutput(result.output);
        if (unitTest) {
          step.unit_test = unitTest;
          entry.unitTest = unitTest;
          console.log(
            chalk.gray(
              `  å•å…ƒæµ‹è¯•ä¿¡æ¯å·²è®°å½•åˆ°æ­¥éª¤ JSONï¼ˆå‘½ä»¤ï¼š${unitTest.command}ï¼‰`,
            ),
          );
        }

        try {
          await fs.writeFile(
            entry.filePath,
            JSON.stringify(step, null, 2),
            "utf-8",
          );
        } catch (err) {
          const message =
            err instanceof Error ? err.message : "æ— æ³•å†™å…¥æ­¥éª¤ JSON æ–‡ä»¶";
          console.log(
            chalk.red(
              `âœ— æ­¥éª¤å·²æˆåŠŸæ‰§è¡Œï¼Œä½†å†™å›çŠ¶æ€åˆ°æ–‡ä»¶æ—¶å¤±è´¥ï¼š${message}`,
            ),
          );
          entry.success = false;
          entry.error = message;
          firstFailure = firstFailure ?? entry;
          shouldAbortRun = true;
          break;
        }

        console.log(
          chalk.green(
            `  âœ“ æ­¥éª¤æ‰§è¡ŒæˆåŠŸï¼ŒçŠ¶æ€å·²æ›´æ–°ä¸ºï¼š${step.status}`,
          ),
        );

        // æ™®é€š run æ¨¡å¼ä¸‹ï¼Œæ‰§è¡Œã€Œå•å…ƒæµ‹è¯• + verification éªŒè¯ã€
        if (mode !== "full-verify") {
          // å…ˆæ‰§è¡Œå•å…ƒæµ‹è¯•ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
          if (entry.unitTest && entry.unitTest.command) {
            console.log(
              chalk.gray(
                `  ğŸ§ª æ‰§è¡Œå•å…ƒæµ‹è¯•: ${entry.unitTest.command}`,
              ),
            );
            const testResult = await runUnitTestsForStep(entry.unitTest, cwd);
            if (!testResult.success) {
              console.log(chalk.red("  âœ— å•å…ƒæµ‹è¯•å¤±è´¥"));
              if (testResult.error) {
                testResult.error
                  .split("\n")
                  .slice(0, 10)
                  .forEach((line) => {
                    if (line.trim()) {
                      console.log(chalk.red(`    ${line}`));
                    }
                  });
              }

              const unitTestOutputSnippet = buildOutputSnippet(
                testResult.error || testResult.output || "",
              );

              step.status = "ğŸ”´ å¾…å®Œæˆ";
              entry.finalStatus = step.status;
              entry.success = false;
              entry.error = "å•å…ƒæµ‹è¯•å¤±è´¥";

              lastFailureContext = {
                attempt,
                maxAttempts: MAX_ATTEMPTS,
                fromStatus: attemptStartStatus,
                toStatus: step.status,
                unitTestCommand: entry.unitTest.command,
                unitTestOutputSnippet,
              };

              if (lastFailureContext) {
                logAttemptFailureSummary(lastFailureContext);
              }

              try {
                await fs.writeFile(
                  entry.filePath,
                  JSON.stringify(step, null, 2),
                  "utf-8",
                );
              } catch {
                // å¦‚æœè¿™é‡Œå†™å›å¤±è´¥ï¼Œé”™è¯¯å·²ç»åœ¨å‰é¢å¤„ç†è¿‡ï¼Œè¿™é‡Œä¸å†é¢å¤–ä¸­æ–­
              }

              const now = new Date();
              await writeProgressMarkdown({
                stepsDir,
                entries,
                startedAt,
                finishedAt: now,
              });

              if (attempt >= MAX_ATTEMPTS) {
                firstFailure = firstFailure ?? entry;
                shouldAbortRun = true;
                break;
              }

              // æœªåˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œç»§ç»­ä¸‹ä¸€è½®å°è¯•
              continue;
            } else {
              console.log(chalk.green("  âœ“ å•å…ƒæµ‹è¯•é€šè¿‡"));
            }
          }

          // å†æŒ‰ verification åˆ—è¡¨è®© AI åšä¸€æ¬¡éªŒè¯
          const validationPrompt = buildRunStepValidationPrompt({
            projectRoot: cwd,
            stepsDir,
            step,
            fileName: entry.fileName,
            order: entry.order,
            total,
          });

          console.log(
            chalk.gray("  æ­£åœ¨è°ƒç”¨å‘½ä»¤è¡Œ AI æŒ‰ verification è¿›è¡ŒéªŒè¯..."),
          );

          const validationResult = await callAnyAvailableAgent(
            validationPrompt,
            {
              cwd,
              verbose: true,
            },
          );

          if (!validationResult.success) {
            console.log(
              chalk.red(
                `  âœ— verification éªŒè¯æœªé€šè¿‡ï¼š${validationResult.error ?? "åŸå› æœªçŸ¥"}`,
              ),
            );

            const verificationError =
              validationResult.error || "verification éªŒè¯å¤±è´¥";

            step.status = "ğŸ”´ å¾…å®Œæˆ";
            entry.finalStatus = step.status;
            entry.success = false;
            entry.error = verificationError;

            lastFailureContext = {
              attempt,
              maxAttempts: MAX_ATTEMPTS,
              fromStatus: attemptStartStatus,
              toStatus: step.status,
              verificationError,
            };

            if (lastFailureContext) {
              logAttemptFailureSummary(lastFailureContext);
            }

            try {
              await fs.writeFile(
                entry.filePath,
                JSON.stringify(step, null, 2),
                "utf-8",
              );
            } catch {
              // åŒä¸Šï¼Œå†™å›å¤±è´¥ä¸å†é¢å¤–ä¸­æ–­
            }

            const now = new Date();
            await writeProgressMarkdown({
              stepsDir,
              entries,
              startedAt,
              finishedAt: now,
            });

            if (attempt >= MAX_ATTEMPTS) {
              firstFailure = firstFailure ?? entry;
              shouldAbortRun = true;
              break;
            }

            // æœªåˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œç»§ç»­ä¸‹ä¸€è½®å°è¯•
            continue;
          } else {
            console.log(chalk.green("  âœ“ verification éªŒè¯é€šè¿‡"));
          }
        }

        if (mode !== "full-verify") {
          console.log(
            chalk.green(
              `  âœ“ ç¬¬ ${attempt} æ¬¡å°è¯•åæ­¥éª¤å·²é€šè¿‡æ‰€æœ‰æµ‹è¯•ä¸éªŒè¯`,
            ),
          );
        }

        const now = new Date();
        await writeProgressMarkdown({
          stepsDir,
          entries,
          startedAt,
          finishedAt: now,
        });

        // å½“å‰è½®æ¬¡å®ç° + éªŒè¯å‡æˆåŠŸï¼Œç»“æŸé‡è¯•å¾ªç¯
        break;
      } else {
        step.status = "ğŸ”´ å¾…å®Œæˆ";
        entry.finalStatus = step.status;
        entry.success = false;
        const aiError = result.error || "AI å­è¿›ç¨‹æ‰§è¡Œå¤±è´¥";
        entry.error = aiError;

        lastFailureContext = {
          attempt,
          maxAttempts: MAX_ATTEMPTS,
          fromStatus: attemptStartStatus,
          toStatus: step.status,
          aiError,
        };

        if (lastFailureContext) {
          logAttemptFailureSummary(lastFailureContext);
        }

        try {
          await fs.writeFile(
            entry.filePath,
            JSON.stringify(step, null, 2),
            "utf-8",
          );
        } catch (err) {
          const message =
            err instanceof Error ? err.message : "æ— æ³•å†™å›å¤±è´¥çŠ¶æ€åˆ°æ­¥éª¤æ–‡ä»¶";
          console.log(
            chalk.red(
              `âœ— æ— æ³•å†™å›å¤±è´¥çŠ¶æ€åˆ°æ­¥éª¤æ–‡ä»¶ï¼š${message}`,
            ),
          );
        }

        console.log(
          chalk.red(
            `âœ— æ­¥éª¤æ‰§è¡Œå¤±è´¥ï¼š${entry.error}`,
          ),
        );

        const now = new Date();
        await writeProgressMarkdown({
          stepsDir,
          entries,
          startedAt,
          finishedAt: now,
        });

        if (attempt >= MAX_ATTEMPTS) {
          firstFailure = firstFailure ?? entry;
          shouldAbortRun = true;
          break;
        }

        // æœªåˆ°æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œç»§ç»­ä¸‹ä¸€è½®å°è¯•
        continue;
      }
    }

    if (shouldAbortRun) {
      break;
    }
  }

  const successCount = entries.filter((e) => e.success).length;
  const totalSteps = entries.length;

  console.log("");
  console.log(
    chalk.bold(
      `ğŸ“‹ æœ¬æ¬¡ run æ‰§è¡Œç»“æœï¼š${successCount}/${totalSteps} ä¸ªæ­¥éª¤æ‰§è¡ŒæˆåŠŸ`,
    ),
  );

  if (firstFailure) {
    console.log(
      chalk.red(
        `âœ— ç¬¬ä¸€ä¸ªå¤±è´¥çš„æ­¥éª¤ï¼š${firstFailure.fileName}${
          firstFailure.id ? ` (${firstFailure.id})` : ""
        }`,
      ),
    );
    if (firstFailure.error) {
      console.log(chalk.red(`  é”™è¯¯åŸå› ï¼š${firstFailure.error}`));
    }
    process.exitCode = 1;
  } else {
    console.log(chalk.green("âœ“ æ‰€æœ‰æ­¥éª¤å‡å·²æˆåŠŸæ‰§è¡Œ"));
  }

  const finishedAt = new Date();
  const progressPath = await writeProgressMarkdown({
    stepsDir,
    entries,
    startedAt,
    finishedAt,
  });
  console.log(chalk.gray(`  æ‰§è¡Œè¿›åº¦æŠ¥å‘Šå·²å†™å…¥ï¼š${progressPath}`));
}
